<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Climb</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            width: 100%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            background-color: #1a1a2e; /* Dark theme for the tower */
            border: 4px solid #3c004d;
        }
        canvas {
            display: block;
            background: linear-gradient(to bottom, #10001f 0%, #1a1a2e 100%);
        }
        .controls {
            padding: 16px;
            text-align: center;
            background-color: #1a1a2e;
            border-top: 1px solid #3c004d;
        }
        .controls p {
            margin: 4px 0;
            font-size: 0.9rem;
            color: #999;
        }
        .control-key {
            display: inline-block;
            background-color: #3c004d;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: bold;
            box-shadow: 0 2px #28003a;
        }
        
        /* Message Box / Modals (Game Over & Leaderboard) */
        .message-box {
            position: fixed; /* Use fixed for proper overlay */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(44, 44, 60, 0.98);
            border: 3px solid #ff416c;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            min-width: 280px;
            max-width: 90%;
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.5);
            display: none; /* Initially hidden */
        }
        .message-box h2 {
            font-size: 1.8rem;
            color: #ff416c;
            margin-bottom: 10px;
        }
        .message-box p {
            margin-bottom: 20px;
            color: #ccc;
        }
        
        /* Buttons in Message Box */
        .message-box button {
            background-color: #ff416c;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        .message-box button:hover {
            background-color: #e03a5e;
        }
        .message-box button:active {
            transform: scale(0.98);
        }

        /* --- Leaderboard Specific Styles --- */
        #leaderboardModal h2 {
            color: #4dffa6; /* Green for leaderboard title */
        }
        
        #leaderboardContent {
            max-height: 300px; 
            overflow-y: auto;
            margin-top: 20px;
            padding-right: 10px;
            border-top: 1px solid #3c004d;
            padding-top: 15px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px dashed rgba(153, 153, 153, 0.3);
            font-size: 1rem;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            font-weight: bold;
            color: #4dffa6; 
            width: 30px;
            font-size: 1.2rem;
        }

        .leaderboard-name {
            flex-grow: 1;
            color: #e0e0e0;
            text-align: left;
            margin-left: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #ffeb3b; 
            min-width: 60px;
            text-align: right;
        }

        /* --- Touch Controls --- */
        #touchControls {
            display: flex;
            justify-content: space-between;
            padding: 1rem;
            background-color: #0d0d1a;
        }

        .touch-button {
            width: 70px;
            height: 70px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px rgba(0, 0, 0, 0.4);
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            transition: transform 0.1s, opacity 0.1s;
            opacity: 0.85; 
        }
        .touch-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px rgba(0, 0, 0, 0.4);
            opacity: 1;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="gameCanvas" width="500" height="650"></canvas>
        <div class="controls">
            <p>Controls: Move <span class="control-key">←</span> <span class="control-key">→</span> Jump/Float <span class="control-key">↑</span></p>
            <p>Fire Laser with <span class="control-key">X</span></p> 
            <p id="level-display" class="font-bold text-lg text-fuchsia-400 mt-2"></p>
            <div class="flex justify-center space-x-6">
                <p id="tool-display" class="font-bold text-lg text-cyan-400"></p>
                <p id="poison-display" class="font-bold text-lg text-red-500"></p>
            </div>
            <button id="viewLeaderboardButton" class="mt-4 px-4 py-2 bg-purple-700 hover:bg-purple-600 text-white font-bold rounded-lg shadow-lg transition duration-150">View Leaderboard</button>
        </div>

        <div id="touchControls">
            <div class="flex space-x-4">
                <button id="touchLeft" class="touch-button bg-blue-700">←</button>
                <button id="touchRight" class="touch-button bg-blue-700">→</button>
            </div>
            <div class="flex space-x-4">
                <button id="touchFire" class="touch-button bg-red-600">Fire (X)</button>
                <button id="touchJump" class="touch-button bg-green-600">Jump (↑)</button>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <h2 id="messageTitle"></h2>
        <p id="messageText"></p>
        <div id="scoreSubmitForm" class="hidden">
            <label for="playerName" class="block mb-2 text-sm font-medium text-gray-300">Enter Your Name:</label>
            <input type="text" id="playerName" maxlength="15" placeholder="Player Name" class="mb-4 w-full p-2 bg-gray-700 border border-purple-500 rounded text-white text-center">
            <button id="saveScoreButton" class="w-full">Save Score & Restart</button>
            <button id="restartWithoutSaveButton" class="mt-2 w-full bg-gray-600 hover:bg-gray-500">Restart Without Saving</button>
        </div>
        <button id="restartButton" class="hidden">Try Again</button>
    </div>
    
    <div id="leaderboardModal" class="message-box">
        <h2 class="text-fuchsia-400">Hall of Ascent</h2>
        <div id="leaderboardContent">
            <p class="text-center text-gray-400">Loading scores...</p>
        </div>
        <button id="closeLeaderboardButton" class="mt-4 bg-purple-700 hover:bg-purple-600">Close</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // IMPORT REALTIME DATABASE FUNCTIONS INSTEAD OF FIRESTORE
        import { getDatabase, ref, push, onValue, off, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Firebase Configuration and Initialization ---
        
        // 1. SET THE APP ID HERE
        const appId = 'games-d836d'; // Your app ID / Folder name
        
        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDyMbSVjBTVStyRXOEo38IeMcM4LWTdJ-I",
            authDomain: "games-d836d.firebaseapp.com",
            databaseURL: "https://games-d836d-default-rtdb.firebaseio.com",
            projectId: "games-d836d",
            storageBucket: "games-d836d.firebasestorage.app",
            messagingSenderId: "228157907811",
            appId: "1:228157907811:web:c2a536b3b3bb6ade5e6956"
        };
        
        // --- GLOBAL VARIABLES FOR FIREBASE ---
        // FIX: Declare variables outside the function scope to be globally accessible.
        let app = null;
        let auth = null;
        let db = null;
        let userId = 'anon';

        // --- Game Setup and Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game Mechanics Constants
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = -15;
        const GRAVITY = 0.6;
        const WALL_X = 50;
        const WALL_WIDTH = canvas.width - 100;
        
        // Kirby Jump Constants
        const MAX_JUMPS = 2; 
        const FLOAT_GRAVITY = 0.2; 
        const FLOAT_FALL_CAP = 4; 
        
        // Platform Generation Constants
        const PLATFORM_GAP_MIN = 80; 
        const PLATFORM_GAP_MAX = 140; 
        const PLATFORM_WIDTH_MIN = 70;
        const PLATFORM_WIDTH_MAX = 200;
        const GENERATION_BUFFER_Y = 450; 

        // State variables for infinite generation
        let highestPlatformY = 0; 
        let scrollY = 0; 
        let distanceClimbed = 0; 

        let gameState = {
            player: null,
            platforms: [],
            obstacles: [], 
            tools: [], 
            mushrooms: [], // Poison mushrooms
            antidotes: [], // Antidote mushrooms
            lasers: [], 
            isGameOver: false,
            keys: {}
        };

        const levelDisplay = document.getElementById('level-display');
        const toolDisplay = document.getElementById('tool-display'); 
        const poisonDisplay = document.getElementById('poison-display'); 
        
        // Game Over/Submission DOM elements
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton'); // Hidden now

        const scoreSubmitForm = document.getElementById('scoreSubmitForm');
        const playerNameInput = document.getElementById('playerName');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const restartWithoutSaveButton = document.getElementById('restartWithoutSaveButton');
        
        // Leaderboard DOM elements
        const viewLeaderboardButton = document.getElementById('viewLeaderboardButton');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const leaderboardContent = document.getElementById('leaderboardContent');
        const closeLeaderboardButton = document.getElementById('closeLeaderboardButton');
        let leaderboardUnsubscribe = null; // RTDB listeners use 'off' instead of a returned unsubscribe function


        // --- Name Generation Logic ---
        const ADJECTIVES = ['Sly', 'Swift', 'Brave', 'Crimson', 'Azure', 'Iron', 'Golden', 'Mystic', 'Silent', 'Wily', 'Cosmic', 'Shadow', 'Peak'];
        const NOUNS = ['Climber', 'Tower', 'Ascender', 'Phantom', 'Jumper', 'Racer', 'Bot', 'Star', 'Hawk', 'Shroom', 'Wisp', 'Vortex', 'Orb'];

        /**
         * Generates a random player name (e.g., SwiftRacer42).
         * @returns {string}
         */
        const generateRandomName = () => {
            const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
            const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
            const num = Math.floor(Math.random() * 99) + 1;
            return `${adj}${noun}${num}`;
        };


        // --- Firebase/Leaderboard Logic (UPDATED FOR RTDB) ---

        /**
         * Gets the reference to the public 'scores' path in Realtime Database.
         * Path: /artifacts/{appId}/public/data/scores
         */
        const getScoresRef = () => {
             // In RTDB, we use the root path relative to the URL for public data.
            return ref(db, `artifacts/${appId}/public/data/scores`);
        };

        /**
         * Saves the current score to Realtime Database.
         * @param {string} name 
         * @param {number} score 
         */
        const saveScore = async (name, score) => {
            if (!db) {
                console.warn("Database not initialized. Cannot save score.");
                return;
            }

            const data = {
                name: name || 'Anonymous Climber',
                score: Math.floor(score), // Store as integer meters (must be a number for orderByChild)
                timestamp: Date.now(),
                userId: userId, 
            };

            try {
                // Use push() to automatically generate a unique ID for the score entry
                await push(getScoresRef(), data);
                console.log(`Score ${score} saved successfully by ${name}.`);
            } catch (e) {
                console.error("Error adding score to RTDB: ", e);
            }
        };

        /**
         * Renders the leaderboard content based on the fetched scores array.
         * @param {Array<Object>} scores
         */
        const renderLeaderboard = (scores) => {
            let html = '<div class="leaderboard-item font-bold text-gray-400 border-none"><span class="leaderboard-rank">#</span><span class="leaderboard-name">Player</span><span class="leaderboard-score">Meters</span></div>';
            
            if (scores.length === 0) {
                html += '<p class="text-center text-gray-400 py-4">No scores recorded yet!</p>';
            } else {
                // Scores are already sorted descending by the RTDB query
                scores.forEach((score, index) => {
                    html += `
                        <div class="leaderboard-item">
                            <span class="leaderboard-rank">${index + 1}.</span>
                            <span class="leaderboard-name">${score.name}</span>
                            <span class="leaderboard-score">${score.score}</span>
                        </div>
                    `;
                });
            }
            leaderboardContent.innerHTML = html;
        };

        /**
         * Sets up the real-time listener for the leaderboard using RTDB.
         */
        const setupLeaderboardListener = () => {
            if (!db) {
                 leaderboardContent.innerHTML = '<p class="text-center text-red-400 py-4">Database not available.</p>';
                 return;
            }

            // Reference to the scores path
            const scoresRef = getScoresRef();

            // Create a query to order by score (ascending by default) and limit to the last 10 (highest scores)
            // RTDB default is ascending, so limitToLast(10) gives us the 10 highest scores.
            const leaderboardQuery = query(
                scoresRef,
                orderByChild('score'),
                limitToLast(10)
            );
            
            // Unsubscribe from previous listener if it exists (using the off() function)
            // Note: Since we are using onValue with a query reference, we need to manually track the reference 
            // if we wanted to turn it off specifically. For simplicity in this single-file setup,
            // we will just rely on the 'off' if we had a more complex setup, but 'onValue' on the query ref
            // is sufficient for real-time updates.

            // The onValue listener returns a function that can be used to stop the listener.
            // However, RTDB listeners are often cleaned up by component unmounting. 
            // Here, we'll keep it simple and just listen. If we need to stop, we'll use off(scoresRef)
            // which stops ALL listeners on that reference.

            // Start listening
            onValue(leaderboardQuery, (snapshot) => {
                const scoresObject = snapshot.val();
                let scores = [];

                if (scoresObject) {
                    // Convert object of scores into an array
                    for (let key in scoresObject) {
                        scores.push(scoresObject[key]);
                    }
                }
                
                // The query is orderByChild('score') and limitToLast(10). 
                // limitToLast(10) gets the highest 10, but the result is still ordered ASCENDINGLY by key/insertion order.
                // We must sort them locally to ensure DESCENDING score order for display.
                scores.sort((a, b) => b.score - a.score); 

                renderLeaderboard(scores);
            }, (error) => {
                console.error("Error fetching leaderboard: ", error);
                leaderboardContent.innerHTML = '<p class="text-center text-red-400 py-4">Error loading scores. Check console for details.</p>';
            });
        };


        // --- Game Classes ---
        // ... (All classes remain unchanged)
        
        class Player {
            constructor(x, y) {
                this.width = 20;
                this.height = 30;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.jumpsUsed = 0; 
                this.color = '#ffeb3b';
                
                // Tool properties
                this.currentTool = 'none';
                this.laserCooldown = 0; 

                // Poison properties
                this.poisonHits = 0; // 3 hits max
                this.flashTimer = 0; // For player visual feedback
            }

            update() {
                // Update cooldown and flashing timer
                if (this.laserCooldown > 0) {
                    this.laserCooldown--;
                }
                if (this.flashTimer > 0) {
                    this.flashTimer--;
                }
                updatePoisonDisplay(); // Update UI

                // Apply Kirby Float/Gravity Logic
                const isHoldingJump = gameState.keys['ArrowUp'];
                const isInAir = !this.onGround;

                if (isInAir && this.jumpsUsed === MAX_JUMPS && isHoldingJump) {
                    this.vy += FLOAT_GRAVITY;
                    this.vy = Math.min(this.vy, FLOAT_FALL_CAP); 
                } else {
                    this.vy += GRAVITY;
                }
                
                // Horizontal movement
                if (gameState.keys['ArrowLeft']) {
                    this.vx = -PLAYER_SPEED;
                } else if (gameState.keys['ArrowRight']) {
                    this.vx = PLAYER_SPEED;
                } else {
                    this.vx = 0;
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Boundary checks
                if (this.x < WALL_X) {
                    this.x = WALL_X;
                }
                if (this.x + this.width > WALL_X + WALL_WIDTH) {
                    this.x = WALL_X + WALL_WIDTH - this.width;
                }
            }

            jump() {
                if (this.jumpsUsed < MAX_JUMPS) {
                    this.vy = JUMP_FORCE; 
                    this.onGround = false;
                    this.jumpsUsed++;
                }
            }
            
            // Fire Laser Method
            fireLaser() {
                if (this.currentTool === 'laser_gun' && this.laserCooldown <= 0) {
                    const laserX = this.x + this.width / 2 - 2; // Center of player
                    const laserY = this.y; // Top of player
                    
                    gameState.lasers.push(new Laser(laserX, laserY));
                    
                    this.laserCooldown = 15; // Small cooldown to prevent too much spam
                    updateToolDisplay(); // Update UI
                }
            }

            draw() {
                // Flashing Logic: Blink every 5 frames if flashTimer is active
                if (this.flashTimer > 0 && Math.floor(this.flashTimer / 5) % 2 === 0) {
                    ctx.globalAlpha = 0.5; // Make player half transparent when flashing
                } else {
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.width, this.height);
                
                ctx.globalAlpha = 1.0; // Reset alpha for other drawings
            }
        }

        class Platform {
            constructor(level, x, y_absolute, w, h, type = 'static', speed = 0) {
                this.x = x;
                this.y = y_absolute; 
                this.w = w;
                this.h = h;
                this.type = type;
                this.speed = speed;
                this.color = '#ff416c'; 
                this.startY = y_absolute;
                this.startX = x; 

                if (type.includes('moving')) {
                    this.color = '#4dffa6';
                }
            }

            update() {
                if (this.type === 'moving-h') {
                    this.x += this.speed;
                    if (this.x < WALL_X || this.x + this.w > WALL_X + WALL_WIDTH) {
                        this.speed *= -1;
                    }
                } else if (this.type === 'moving-v') {
                    this.y += this.speed;
                    if (this.y < this.startY - 100 || this.y > this.startY + 100) {
                        this.speed *= -1;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.w, this.h);
            }
        }

        class Obstacle {
            constructor(x, y_absolute, w, h, type = 'sweeper', speed = 0) {
                this.x = x;
                this.y = y_absolute; 
                this.w = w;
                this.h = h;
                this.type = type;
                this.speed = speed;
                this.color = '#ff0000';
                this.startY = y_absolute; 
                this.startX = x;
                this.toRemove = false; 
            }

            update() {
                if (this.type === 'sweeper') {
                    this.x += this.speed;
                    if (this.x < WALL_X || this.x + this.w > WALL_X + WALL_WIDTH) {
                        this.speed *= -1;
                    }
                } else if (this.type === 'bouncer') {
                    this.y += this.speed;
                    if (this.y < this.startY - 150 || this.y > this.startY + 150) {
                        this.speed *= -1;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.w, this.h);
                
                ctx.fillStyle = '#ff9999';
                ctx.fillRect(this.x, this.y - scrollY, this.w, 3);
                ctx.fillRect(this.x, this.y - scrollY + this.h - 3, this.w, 3);
            }
        }
        
        class BaseMushroom {
            constructor(x, y_absolute, parentPlatform, capColor, dotColor) {
                this.x = x;
                this.y = y_absolute; 
                this.w = 15;
                this.h = 15;
                this.toRemove = false;
                this.platform = parentPlatform;
                this.speed = 0.8; 
                this.capColor = capColor;
                this.dotColor = dotColor;
                this.minX = this.platform.x + 5;
                this.maxX = this.platform.x + this.platform.w - this.w - 5;
            }

            update() {
                this.minX = this.platform.x + 5;
                this.maxX = this.platform.x + this.platform.w - this.w - 5;

                this.x += this.speed;

                if (this.x < this.minX || this.x > this.maxX) {
                    this.speed *= -1;
                }
                
                if (this.platform.type.includes('moving')) {
                    this.y = this.platform.y - this.h;
                }
            }

            draw() {
                const screenY = this.y - scrollY;
                
                // Base/Stem color (Dark Grey)
                ctx.fillStyle = '#333333'; 
                ctx.fillRect(this.x + this.w/2 - 3, screenY + 5, 6, 10);
                
                // Cap color 
                ctx.fillStyle = this.capColor; 
                ctx.beginPath();
                ctx.arc(this.x + this.w / 2, screenY + 5, this.w / 2, Math.PI, 0, false);
                ctx.closePath();
                ctx.fill();

                // Add small spots 
                ctx.fillStyle = this.dotColor;
                ctx.fillRect(this.x + 3, screenY + 2, 2, 2);
                ctx.fillRect(this.x + 10, screenY + 2, 2, 2);
            }
        }
        
        // Poison Mushroom (Red)
        class PoisonMushroom extends BaseMushroom {
            constructor(x, y_absolute, parentPlatform) {
                super(x, y_absolute, parentPlatform, '#CC0000', '#FFFFFF');
            }
        }
        
        // Antidote Mushroom (Green)
        class AntidoteMushroom extends BaseMushroom {
            constructor(x, y_absolute, parentPlatform) {
                super(x, y_absolute, parentPlatform, '#34D399', '#FFFFFF'); // Emerald Green
            }
        }
        
        // Tool Class
        class Tool {
            constructor(x, y_absolute, type) {
                this.x = x;
                this.y = y_absolute;
                this.width = 15;
                this.height = 15;
                this.type = type;
                this.color = '#00FFFF'; // Cyan for laser gun
                this.toRemove = false;
            }

            draw() {
                // Draw as a triangle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y - scrollY); // Top center
                ctx.lineTo(this.x, this.y - scrollY + this.height); // Bottom left
                ctx.lineTo(this.x + this.width, this.y - scrollY + this.height); // Bottom right
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Laser Class
        class Laser {
            constructor(x, y_absolute) {
                this.x = x;
                this.y = y_absolute;
                this.width = 4;
                this.height = 20;
                this.vy = -35; 
                this.color = '#FFFF00'; 
                this.toRemove = false;
            }
            
            update() {
                this.y += this.vy;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.width, this.height);
            }
        }

        // --- Game Logic Functions ---
        
        function generateNewPlatforms(start_y) {
            let current_y = start_y;
            const targetY = current_y - GENERATION_BUFFER_Y;
            let previous_y = start_y; 

            while (current_y > targetY) {
                const y_gap = Math.floor(Math.random() * (PLATFORM_GAP_MAX - PLATFORM_GAP_MIN) + PLATFORM_GAP_MIN);
                current_y -= y_gap;

                // Determine platform properties
                const w = Math.floor(Math.random() * (PLATFORM_WIDTH_MAX - PLATFORM_WIDTH_MIN) + PLATFORM_WIDTH_MIN);
                const max_x = WALL_X + WALL_WIDTH - w;
                const x = Math.floor(Math.random() * (max_x - WALL_X) + WALL_X);
                const h = 10;
                
                // Randomly decide platform type
                const rand = Math.random();
                let type = 'static';
                let speed = 0;
                if (rand > 0.7) {
                    if (Math.random() > 0.5) {
                        type = 'moving-h';
                        speed = Math.random() < 0.5 ? 1.5 : -1.5;
                    } else {
                        type = 'moving-v';
                        speed = Math.random() < 0.5 ? 1 : -1;
                    }
                }

                // Push platform
                const p = new Platform(0, x, current_y, w, h, type, speed);
                gameState.platforms.push(p);

                // 1. Tool Generation
                if (p.type === 'static' && Math.random() < 0.08 && (!gameState.player || gameState.player.currentTool === 'none')) {
                    const tool_w = 15;
                    const tool_h = 15;
                    const tool_x = p.x + (p.w / 2) - (tool_w / 2);
                    const tool_y = p.y - tool_h - 2;
                    gameState.tools.push(new Tool(tool_x, tool_y, 'laser_gun'));
                }

                // 2. Poison Mushroom Generation (Red, 15% chance)
                if (p.type === 'static' && Math.random() < 0.15 && p.w > 40) {
                    const mush_w = 15;
                    const mush_h = 15;
                    const mush_x = p.x + (p.w / 2) - (mush_w / 2); // Start in center
                    const mush_y = p.y - mush_h;
                    gameState.mushrooms.push(new PoisonMushroom(mush_x, mush_y, p));
                }
                
                // 3. Antidote Mushroom Generation (Green, 8% chance)
                if (p.type === 'static' && Math.random() < 0.08 && p.w > 40) {
                    const mush_w = 15;
                    const mush_h = 15;
                    const mush_x = p.x + (p.w / 2) - (mush_w / 2);
                    const mush_y = p.y - mush_h;
                    gameState.antidotes.push(new AntidoteMushroom(mush_x, mush_y, p));
                }

                // 4. Obstacle Generation Logic (between platforms)
                if (Math.random() < 0.25) {
                    const obs_w = Math.floor(Math.random() * 40) + 20;
                    const obs_h = 20;
                    const safe_margin = 10;
                    const obs_y_min = current_y + obs_h + safe_margin;
                    const obs_y_max = previous_y - safe_margin - 30;
                    
                    if (obs_y_max > obs_y_min) {
                        const obs_y = Math.floor(Math.random() * (obs_y_max - obs_y_min) + obs_y_min);
                        const obs_x_max = WALL_X + WALL_WIDTH - obs_w;
                        const obs_x = Math.floor(Math.random() * (obs_x_max - WALL_X) + WALL_X);
                        
                        let obs_type = Math.random() > 0.5 ? 'sweeper' : 'bouncer';
                        let obs_speed = obs_type === 'sweeper' ? (Math.random() < 0.5 ? 2.5 : -2.5) : (Math.random() < 0.5 ? 1.5 : -1.5);

                        gameState.obstacles.push(new Obstacle(obs_x, obs_y, obs_w, obs_h, obs_type, obs_speed));
                    }
                }

                previous_y = current_y + y_gap;
                highestPlatformY = Math.min(highestPlatformY, current_y);
            }
        }

        function loadInitialLevels() {
            gameState.platforms = [];
            gameState.obstacles = [];
            gameState.tools = [];
            gameState.lasers = [];
            gameState.mushrooms = [];
            gameState.antidotes = [];
            
            highestPlatformY = canvas.height;

            // Create starting platform
            gameState.platforms.push(new Platform(0, WALL_X, canvas.height - 30, WALL_WIDTH, 30, 'static'));

            // Set player position
            gameState.player = new Player(canvas.width / 2 - 10, canvas.height - 60);
            gameState.player.vy = 0;
            gameState.player.currentTool = 'none';
            gameState.player.poisonHits = 0;
            gameState.player.flashTimer = 0;

            // Generate initial set of platforms
            generateNewPlatforms(canvas.height - 100);

            // Reset scroll and score
            scrollY = 0;
            distanceClimbed = 0;
            updateLevelDisplay();
            updateToolDisplay();
            updatePoisonDisplay();
            
            // Ensure the score submission form is hidden upon restart
            scoreSubmitForm.classList.add('hidden'); 
            messageBox.style.display = 'none'; 
        }

        function checkCollision(obj1, obj2) {
            // obj1 has width/height, obj2 has w/h
            return (
                obj1.x < obj2.x + obj2.w &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.h &&
                obj1.y + obj1.height > obj2.y
            );
        }

        function updateGame() {
            if (gameState.isGameOver) return;

            gameState.player.update();

            const discardThresholdY = scrollY + canvas.height + 100;

            // Update and Filter Entities
            gameState.platforms.forEach(p => p.update());
            gameState.platforms = gameState.platforms.filter(p => p.y < discardThresholdY);
            
            gameState.obstacles.forEach(o => o.update());
            gameState.obstacles = gameState.obstacles.filter(o => !o.toRemove && o.y < discardThresholdY);
            
            gameState.mushrooms.forEach(m => m.update());
            gameState.mushrooms = gameState.mushrooms.filter(m => !m.toRemove && m.y < discardThresholdY);

            gameState.antidotes.forEach(a => a.update());
            gameState.antidotes = gameState.antidotes.filter(a => !a.toRemove && a.y < discardThresholdY);
            
            gameState.lasers.forEach(l => l.update());
            gameState.lasers = gameState.lasers.filter(l => !l.toRemove && l.y > scrollY - 20); // Laser removes itself if it goes far off-screen upwards

            // --- Collision Detection ---
            const player = gameState.player;
            const oldOnGround = player.onGround;
            player.onGround = false;

            // Platform collision (only from top)
            gameState.platforms.forEach(p => {
                if (
                    player.vy > 0 && // Player is falling
                    player.x + player.width > p.x && 
                    player.x < p.x + p.w &&
                    player.y + player.height <= p.y + p.h / 2 && // Must be slightly above or at platform top
                    player.y + player.height + player.vy >= p.y // Check if next position will hit the platform
                ) {
                    player.y = p.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                    player.jumpsUsed = 0;
                    
                    // If platform is moving, player moves with it
                    if (p.type === 'moving-h') {
                        player.x += p.speed;
                    } else if (p.type === 'moving-v') {
                        player.y += p.speed;
                    }
                }
            });

            // Player falls off screen (Game Over condition)
            if (player.y - scrollY > canvas.height) {
                gameOver('You fell into the abyss');
                return;
            }

            // Player hits ceiling (bounce down slightly)
            const ceilingY = highestPlatformY - 50; 
            if (player.y < ceilingY && scrollY > 0) {
                player.y = ceilingY;
                player.vy = 0; 
            }
            
            // Obstacle collision
            gameState.obstacles.forEach(o => {
                if (checkCollision(player, o) && player.flashTimer <= 0) {
                    gameOver('You were caught by a dangerous hazard');
                    return;
                }
            });

            // Tool collision
            gameState.tools.forEach(tool => {
                if (checkCollision(player, tool)) {
                    player.currentTool = tool.type; // 'laser_gun'
                    player.laserCooldown = 0;
                    tool.toRemove = true;
                    updateToolDisplay();
                }
            });
            gameState.tools = gameState.tools.filter(t => !t.toRemove);


            // Poison Mushroom collision
            gameState.mushrooms.forEach(m => {
                if (checkCollision(player, m)) {
                    if (player.poisonHits < 3) {
                        player.poisonHits++;
                        player.flashTimer = 50; // Flash for visual feedback
                        updatePoisonDisplay();
                    }
                    m.toRemove = true;
                    if (player.poisonHits >= 3) {
                        gameOver('You consumed too much poison!');
                        return;
                    }
                }
            });
            gameState.mushrooms = gameState.mushrooms.filter(m => !m.toRemove);
            
            // Antidote Mushroom collision
            gameState.antidotes.forEach(a => {
                if (checkCollision(player, a)) {
                    if (player.poisonHits > 0) {
                        player.poisonHits--;
                        player.flashTimer = 30; 
                        updatePoisonDisplay();
                    }
                    a.toRemove = true;
                }
            });
            gameState.antidotes = gameState.antidotes.filter(a => !a.toRemove);


            // Laser collision with Obstacle
            gameState.lasers.forEach(laser => {
                gameState.obstacles.forEach(obstacle => {
                    if (checkCollision(laser, obstacle)) {
                        laser.toRemove = true;
                        obstacle.toRemove = true; 
                    }
                });
            });


            // --- Screen Scrolling & Generation ---
            // If player is high on the screen, adjust scroll (center the player vertically)
            const playerScreenY = player.y - scrollY;
            const centerHeight = canvas.height * 0.4; // 40% up from the bottom
            
            if (playerScreenY < centerHeight) {
                scrollY = player.y - centerHeight;
            }

            // Update distance climbed (score)
            distanceClimbed = Math.max(distanceClimbed, canvas.height - player.y);
            updateLevelDisplay();


            // Platform generation when player climbs higher
            if (scrollY < highestPlatformY - GENERATION_BUFFER_Y) {
                generateNewPlatforms(highestPlatformY - 100);
            }
        }

        function drawGame() {
            if (gameState.isGameOver) {
                // Draw last frame of game before message box
                drawEntities();
            } else {
                requestAnimationFrame(drawGame);
                updateGame();
                drawEntities();
            }
        }

        function drawEntities() {
             // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw boundaries (walls)
            ctx.fillStyle = '#3c004d'; // Purple walls
            ctx.fillRect(0, 0, WALL_X, canvas.height); // Left wall
            ctx.fillRect(WALL_X + WALL_WIDTH, 0, WALL_X, canvas.height); // Right wall

            // Draw all entities
            gameState.platforms.forEach(p => p.draw());
            gameState.obstacles.forEach(o => o.draw());
            gameState.tools.forEach(t => t.draw());
            gameState.mushrooms.forEach(m => m.draw());
            gameState.antidotes.forEach(a => a.draw());
            gameState.lasers.forEach(l => l.draw());

            // Draw player
            if (gameState.player) {
                gameState.player.draw();
            }
        }

        function updateLevelDisplay() {
            levelDisplay.textContent = `Climb: ${distanceClimbed.toFixed(0)} meters`;
        }
        
        function updateToolDisplay() {
            toolDisplay.textContent = `Tool: ${gameState.player.currentTool === 'laser_gun' ? 'LASER (X)' : 'None'}`;
        }
        
        function updatePoisonDisplay() {
             poisonDisplay.textContent = `Poison: ${gameState.player.poisonHits} / 3`;
             if (gameState.player.poisonHits > 0) {
                 poisonDisplay.classList.remove('text-red-500', 'text-gray-400');
                 poisonDisplay.classList.add(gameState.player.poisonHits === 3 ? 'text-red-600' : 'text-yellow-500');
             } else {
                 poisonDisplay.classList.remove('text-red-600', 'text-yellow-500');
                 poisonDisplay.classList.add('text-gray-400');
             }
        }

        function gameOver(reason) {
            gameState.isGameOver = true;
            
            messageTitle.textContent = 'Game Over!';
            messageText.innerHTML = `You fell! Your highest climb was: <span class="text-fuchsia-400 font-bold">${distanceClimbed.toFixed(0)} meters</span>. ${reason}`;
            
            // Hide the plain restart button
            restartButton.classList.add('hidden'); 

            // Show the score submission form
            scoreSubmitForm.classList.remove('hidden'); 
            
            // Set a random default name for quick saving
            playerNameInput.value = generateRandomName();

            messageBox.style.display = 'block';
        }

        function resetGame() {
            loadInitialLevels();
            gameState.isGameOver = false;
            drawGame();
        }

        // --- Event Handlers ---
        
        // Key press handlers
        document.addEventListener('keydown', (e) => {
            if (gameState.isGameOver) return;
            
            if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') {
                if (!gameState.keys['ArrowUp']) {
                    gameState.player.jump();
                }
                gameState.keys['ArrowUp'] = true;
            } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                gameState.keys['ArrowLeft'] = true;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                gameState.keys['ArrowRight'] = true;
            } else if (e.key.toLowerCase() === 'x') {
                // Fire laser on press
                gameState.player.fireLaser();
                gameState.keys['x'] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') {
                gameState.keys['ArrowUp'] = false;
            } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                gameState.keys['ArrowLeft'] = false;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                gameState.keys['ArrowRight'] = false;
            } else if (e.key.toLowerCase() === 'x') {
                 gameState.keys['x'] = false;
            }
        });

        // Touch control handlers
        const setupButtonEvents = (button, key, isHoldAction = false) => {
            const pressEvent = () => {
                if (gameState.isGameOver) return;
                gameState.keys[key] = true;
                if (key === 'ArrowUp') {
                    if (!gameState.keys['ArrowUp']) {
                        gameState.player.jump();
                    }
                } else if (key === 'x' && !isHoldAction) {
                    gameState.player.fireLaser();
                }
            };

            const releaseEvent = () => {
                gameState.keys[key] = false;
            };

            button.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                pressEvent();
                if (key === 'x' && isHoldAction) {
                     gameState.player.fireLaser(); // Fire instantly on touch start
                }
            }, { passive: false });
            
            button.addEventListener('touchend', releaseEvent);
            button.addEventListener('mousedown', pressEvent);
            button.addEventListener('mouseup', releaseEvent);
            button.addEventListener('mouseleave', releaseEvent); // Important for mouse drag off
            
            if (isHoldAction) {
                 button.addEventListener('mousedown', () => { 
                    if (gameState.isGameOver) return;
                    gameState.player.fireLaser();
                 });
            }
        };

        // --- Leaderboard & Submission Handlers ---
        
        saveScoreButton.onclick = async () => {
            const finalName = playerNameInput.value.trim() || generateRandomName();
            
            saveScoreButton.disabled = true;
            saveScoreButton.textContent = 'Saving...';
            
            // Save the score asynchronously
            await saveScore(finalName, distanceClimbed);
            
            // Reset the UI state and restart
            saveScoreButton.disabled = false;
            saveScoreButton.textContent = 'Save Score & Restart';
            messageBox.style.display = 'none';
            scoreSubmitForm.classList.add('hidden');
            
            resetGame();
        };

        restartWithoutSaveButton.onclick = () => {
            messageBox.style.display = 'none';
            scoreSubmitForm.classList.add('hidden');
            resetGame();
        };

        viewLeaderboardButton.onclick = () => {
            setupLeaderboardListener(); // Start listening for updates
            leaderboardModal.style.display = 'block';
        };

        closeLeaderboardButton.onclick = () => {
            leaderboardModal.style.display = 'none';
            // Stop ALL listeners on the scores path when the modal is closed
            if (db) {
                off(getScoresRef()); 
            }
        };
        
        // --- Initialization ---

        const startGame = () => {
            // Setup controls
            const touchLeft = document.getElementById('touchLeft');
            const touchRight = document.getElementById('touchRight');
            const touchJump = document.getElementById('touchJump');
            const touchFire = document.getElementById('touchFire');
            
            setupButtonEvents(touchLeft, 'ArrowLeft');
            setupButtonEvents(touchRight, 'ArrowRight');
            setupButtonEvents(touchJump, 'ArrowUp'); // Jump/Float
            setupButtonEvents(touchFire, 'x', true); // Fire is an instant action + hold for rapid fire

            // Start the game
            resetGame();
        }

        /**
         * Initializes Firebase authentication and then calls startGame().
         */
        const initGame = async () => {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    
                    // FIX: app, db, and auth were not globally accessible/properly initialized here.
                    // FIX: Removed the redundant check and assignment of databaseURL (it's in the config).
                    // FIX: Removed signInWithCustomToken as initialAuthToken is undefined.
                    
                    // 1. Initialize App
                    app = initializeApp(firebaseConfig);
                    
                    // 2. Initialize Realtime Database
                    db = getDatabase(app); 
                    
                    // 3. Initialize Auth and sign in anonymously
                    auth = getAuth(app);
                    await signInAnonymously(auth);
                    
                    userId = auth.currentUser?.uid || crypto.randomUUID();
                    console.log("Firebase Auth successful. User ID:", userId);
                    console.log("Realtime Database connected at:", firebaseConfig.databaseURL);

                } else {
                    console.warn("Firebase config not available. Starting game without database/leaderboard.");
                }
            } catch (e) {
                console.error("Critical Firebase error during initialization/auth:", e);
            }
            
            // ALWAYS start the game loop after attempting Firebase init
            startGame(); 
        };

        // Call the initialization function immediately after the script loads
        initGame();
    </script>
</body>
</html>