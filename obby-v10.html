<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Climb</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            max-height: 850px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            background-color: #1a1a2e; /* Dark theme for the tower */
            border: 4px solid #3c004d;
        }
        canvas {
            display: block;
            flex: 1;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #10001f 0%, #1a1a2e 100%);
        }
        .controls {
            padding: 8px 16px;
            text-align: center;
            background-color: #1a1a2e;
            border-top: 1px solid #3c004d;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .controls p {
            margin: 0;
            font-size: 0.75rem;
            color: #999;
        }
        .control-key {
            display: inline-block;
            background-color: #3c004d;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: bold;
            box-shadow: 0 2px #28003a;
        }
        
        /* Message Box / Modals (Game Over & Leaderboard) */
        .message-box {
            position: fixed; /* Use fixed for proper overlay */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(44, 44, 60, 0.98);
            border: 3px solid #ff416c;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            min-width: 280px;
            max-width: 90%;
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.5);
            display: none; /* Initially hidden */
        }
        .message-box h2 {
            font-size: 1.8rem;
            color: #ff416c;
            margin-bottom: 10px;
        }
        .message-box p {
            margin-bottom: 20px;
            color: #ccc;
        }
        
        /* Buttons in Message Box */
        .message-box button {
            background-color: #ff416c;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        .message-box button:hover {
            background-color: #e03a5e;
        }
        .message-box button:active {
            transform: scale(0.98);
        }

        /* --- Leaderboard Specific Styles --- */
        #leaderboardModal h2 {
            color: #4dffa6; /* Green for leaderboard title */
        }
        
        #leaderboardContent {
            max-height: 300px; 
            overflow-y: auto;
            margin-top: 20px;
            padding-right: 10px;
            border-top: 1px solid #3c004d;
            padding-top: 15px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px dashed rgba(153, 153, 153, 0.3);
            font-size: 1rem;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            font-weight: bold;
            color: #4dffa6; 
            width: 30px;
            font-size: 1.2rem;
        }

        .leaderboard-name {
            flex-grow: 1;
            color: #e0e0e0;
            text-align: left;
            margin-left: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #ffeb3b; 
            min-width: 60px;
            text-align: right;
        }

        /* --- Touch Controls --- */
        #touchControls {
            display: flex;
            justify-content: space-between;
            padding: 1rem;
            background-color: #0d0d1a;
        }

        .touch-button {
            width: 70px;
            height: 70px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px rgba(0, 0, 0, 0.4);
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            transition: transform 0.1s, opacity 0.1s;
            opacity: 0.85; 
        }
        .touch-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px rgba(0, 0, 0, 0.4);
            opacity: 1;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div class="flex justify-between items-center">
                <p id="level-display" class="font-bold text-fuchsia-400"></p>
                <div class="flex space-x-4">
                    <p id="tool-display" class="font-bold text-cyan-400"></p>
                    <p id="poison-display" class="font-bold text-red-500"></p>
                </div>
            </div>

            <div class="flex justify-between items-center border-t border-purple-900/30 pt-1">
                <div class="text-left">
                    <p class="text-[9px] text-gray-500">Logged in as: <span id="displayPlayerName" class="text-purple-400">...</span></p>
                    <p class="text-[9px] text-gray-600 hidden md:block">Keys: ←→ ↑(Jump) X(Fire)</p>
                </div>
                <button id="viewLeaderboardButton" class="px-3 py-1 bg-purple-900 hover:bg-purple-800 text-white text-[10px] font-bold rounded transition duration-150">Leaderboard</button>
            </div>
        </div>

        <div id="touchControls">
            <div class="flex space-x-4">
                <button id="touchLeft" class="touch-button bg-blue-700">←</button>
                <button id="touchRight" class="touch-button bg-blue-700">→</button>
            </div>
            <div class="flex space-x-4">
                <button id="touchFire" class="touch-button bg-red-600">Fire (X)</button>
                <button id="touchJump" class="touch-button bg-green-600">Jump (↑)</button>
            </div>
        </div>
    </div>

    
    <div id="leaderboardModal" class="message-box">
        <h2 class="text-fuchsia-400">Hall of Ascent</h2>
        
        <div class="mt-4 p-3 bg-gray-800 rounded border border-purple-500 text-left">
            <label for="playerName" class="block text-xs font-bold text-purple-300 mb-1 uppercase tracking-wider">Your Display Name</label>
            <div class="flex space-x-2">
                <input type="text" id="playerName" maxlength="15" placeholder="Enter name..." class="flex-1 p-1 bg-gray-700 border border-gray-600 rounded text-white text-sm outline-none focus:border-fuchsia-500">
                <button id="updateNameButton" class="bg-fuchsia-700 hover:bg-fuchsia-600 px-3 py-1 rounded text-xs font-bold text-white transition">Update</button>
            </div>
        </div>

        <div id="leaderboardContent">
            <p class="text-center text-gray-400">Loading scores... (Max 10)</p>
        </div>
        <button id="closeLeaderboardButton" class="mt-4 bg-purple-700 hover:bg-purple-600">Close</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"; 
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue, off, query, orderByChild, limitToLast, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Firebase Configuration and Initialization ---
        
        // 1. SET THE APP ID HERE
        const appId = 'games-d836d'; // Your app ID / Folder name
        
        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDyMbSVjBTVStyRXOEo38IeMcM4LWTdJ-I",
            authDomain: "games-d836d.firebaseapp.com", 
            databaseURL: "https://games-d836d-default-rtdb.firebaseio.com",
            projectId: "games-d836d",
            storageBucket: "games-d836d.firebasestorage.app",
            messagingSenderId: "228157907811",
            appId: "1:228157907811:web:c2a536b3b3bb6ade5e6956"
        };
        
        // --- GLOBAL VARIABLES FOR FIREBASE ---
        let app = null;
        let auth = null;
        let db = null;
        let userId = 'anon';

        // --- Local Storage Key ---
        const STORAGE_KEY_NAME = 'climberPlayerName';

        // --- Game Setup and Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const resizeCanvas = () => {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = canvas.clientHeight; // Uses flex height
            
            // Adjust wall width based on new width
            WALL_WIDTH = canvas.width - 100;
        };
        
        // Game Mechanics Constants
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = -15;
        const GRAVITY = 0.6;
        const WALL_X = 50;
        let WALL_WIDTH = 400; // Updated on resize
        
        // Kirby Jump Constants
        const MAX_JUMPS = 2; 
        const FLOAT_GRAVITY = 0.2; 
        const FLOAT_FALL_CAP = 4; 
        
        // Platform Generation Constants
        const PLATFORM_GAP_MIN = 80; 
        const PLATFORM_GAP_MAX = 140; 
        const PLATFORM_WIDTH_MIN = 70;
        const PLATFORM_WIDTH_MAX = 200;
        const GENERATION_BUFFER_Y = 1000; 

        // State variables for infinite generation
        let highestPlatformY = 0; 
        let scrollY = 0; 
        let distanceClimbed = 0; 

        let gameState = {
            player: null,
            platforms: [],
            obstacles: [], 
            tools: [], 
            mushrooms: [], // Poison mushrooms
            antidotes: [], // Antidote mushrooms
            lasers: [], 
            isGameOver: false,
            keys: {}
        };

        const levelDisplay = document.getElementById('level-display');
        const toolDisplay = document.getElementById('tool-display'); 
        const poisonDisplay = document.getElementById('poison-display'); 
        
        // Game Over/Submission DOM elements
        const playerNameInput = document.getElementById('playerName');
        const displayPlayerName = document.getElementById('displayPlayerName');
        const updateNameButton = document.getElementById('updateNameButton');
        
        // Leaderboard DOM elements
        const viewLeaderboardButton = document.getElementById('viewLeaderboardButton');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const leaderboardContent = document.getElementById('leaderboardContent');
        const closeLeaderboardButton = document.getElementById('closeLeaderboardButton');
        

        // --- Local Storage Helpers ---
        const loadPlayerName = () => {
            try {
                return localStorage.getItem(STORAGE_KEY_NAME);
            } catch (e) {
                console.error("Local storage access denied:", e);
                return null;
            }
        };

        const savePlayerName = (name) => {
            try {
                localStorage.setItem(STORAGE_KEY_NAME, name);
            } catch (e) {
                console.error("Local storage write failed:", e);
            }
        };

        // --- Name Generation Logic ---
        const ADJECTIVES = ['Sly', 'Swift', 'Brave', 'Crimson', 'Azure', 'Iron', 'Golden', 'Mystic', 'Silent', 'Wily', 'Cosmic', 'Shadow', 'Peak'];
        const NOUNS = ['Climber', 'Tower', 'Ascender', 'Phantom', 'Jumper', 'Racer', 'Bot', 'Star', 'Hawk', 'Shroom', 'Wisp', 'Vortex', 'Orb'];

        /**
         * Generates a random player name (e.g., SwiftRacer42).
         * @returns {string}
         */
        const generateRandomName = () => {
            const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
            const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
            const num = Math.floor(Math.random() * 99) + 1;
            return `${adj}${noun}${num}`;
        };


        // --- Firebase/Leaderboard Logic ---

        /**
         * Gets the reference to the public 'user_best_scores' path in Realtime Database.
         * This node stores only the high score for each unique user ID.
         */
        const getBestScoresRef = () => {
            return ref(db, `artifacts/${appId}/public/data/user_best_scores`);
        };

        /**
         * Saves the current score to Realtime Database using runTransaction.
         * This ensures the score is only updated if the new score is higher than the existing one.
         * @param {string} name 
         * @param {number} score 
         */
        const saveScore = async (name, score) => {
            if (!db) {
                console.warn("Database not initialized. Cannot save score. Check 'initGame' in the console for 'Critical Firebase error'.");
                return;
            }
            
            if (userId === 'anon') {
                 console.warn("User not authenticated. Cannot save score. Please ensure Anonymous Sign-in is enabled in your Firebase project (Authentication -> Sign-in method tab).");
                 return;
            }

            const finalScore = Math.floor(score);
            // Reference to this specific user's record
            const scoreRef = ref(db, `artifacts/${appId}/public/data/user_best_scores/${userId}`);

            try {
                const { committed, snapshot } = await runTransaction(scoreRef, (currentData) => {
                    // currentData will be null if no record exists for this user ID
                    if (currentData === null || finalScore > currentData.score) {
                        // If no data exists, or new score is better, return the new data
                        return {
                            name: name || 'Anonymous Climber',
                            score: finalScore, 
                            timestamp: Date.now(),
                            userId: userId, 
                        };
                    } else {
                        // Score is not higher, abort transaction by returning undefined
                        return; 
                    }
                });
                
                if (committed) {
                    console.log(`Score ${finalScore} saved/updated successfully by ${name}.`);
                } else {
                    console.log(`Score ${finalScore} was not a new high score for ${name}. Save skipped.`);
                }
            } catch (e) {
                console.error("Error running score transaction in RTDB: ", e);
            }
        };

        /**
         * Renders the leaderboard content based on the fetched scores array.
         * @param {Array<Object>} scores
         */
        const renderLeaderboard = (scores) => {
            let html = '<div class="leaderboard-item font-bold text-gray-400 border-none"><span class="leaderboard-rank">#</span><span class="leaderboard-name">Player</span><span class="leaderboard-score">Meters</span></div>';
            
            if (scores.length === 0) {
                html += '<p class="text-center text-gray-400 py-4">No scores recorded yet!</p>';
            } else {
                // Scores are already sorted descending by the RTDB query
                scores.forEach((score, index) => {
                    html += `
                        <div class="leaderboard-item">
                            <span class="leaderboard-rank">${index + 1}.</span>
                            <span class="leaderboard-name">${score.name}</span>
                            <span class="leaderboard-score">${score.score}</span>
                        </div>
                    `;
                });
            }
            leaderboardContent.innerHTML = html;
        };

        /**
         * Sets up the real-time listener for the leaderboard using RTDB.
         * Now queries the 'user_best_scores' node and limits to the top 10.
         */
        const setupLeaderboardListener = () => {
            if (!db) {
                 leaderboardContent.innerHTML = '<p class="text-center text-red-400 py-4">Database not available.</p>';
                 return;
            }

            // Reference to the best scores path
            const bestScoresRef = getBestScoresRef();

            // Query to order by score (ascending by default) and limit to the last 10 (highest scores)
            const leaderboardQuery = query(
                bestScoresRef,
                orderByChild('score'),
                limitToLast(10) // Limit to top 10 scores
            );
            
            // Start listening
            onValue(leaderboardQuery, (snapshot) => {
                const scoresObject = snapshot.val();
                let scores = [];

                if (scoresObject) {
                    // Convert object of scores into an array
                    for (let key in scoresObject) {
                        scores.push(scoresObject[key]);
                    }
                }
                
                // Sort them locally to ensure DESCENDING score order for display.
                scores.sort((a, b) => b.score - a.score); 

                renderLeaderboard(scores);
            }, (error) => {
                console.error("Error fetching leaderboard: ", error);
                leaderboardContent.innerHTML = '<p class="text-center text-red-400 py-4">Error loading scores. Check console for details.</p>';
            });
        };


        // --- Game Classes (Omitted for brevity, assuming no change needed) ---
        // ... (All classes remain unchanged)
        
        class Player {
            constructor(x, y) {
                this.width = 20;
                this.height = 30;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.jumpsUsed = 0; 
                this.color = '#ffeb3b';
                
                // Tool properties
                this.currentTool = 'none';
                this.laserCooldown = 0; 

                // Poison properties
                this.poisonHits = 0; // 3 hits max
                this.flashTimer = 0; // For player visual feedback
            }

            update() {
                // Update cooldown and flashing timer
                if (this.laserCooldown > 0) {
                    this.laserCooldown--;
                }
                if (this.flashTimer > 0) {
                    this.flashTimer--;
                }
                updatePoisonDisplay(); // Update UI

                // Apply Kirby Float/Gravity Logic
                const isHoldingJump = gameState.keys['ArrowUp'];
                const isInAir = !this.onGround;

                if (isInAir && this.jumpsUsed === MAX_JUMPS && isHoldingJump) {
                    this.vy += FLOAT_GRAVITY;
                    this.vy = Math.min(this.vy, FLOAT_FALL_CAP); 
                } else {
                    this.vy += GRAVITY;
                }
                
                // Horizontal movement
                if (gameState.keys['ArrowLeft']) {
                    this.vx = -PLAYER_SPEED;
                } else if (gameState.keys['ArrowRight']) {
                    this.vx = PLAYER_SPEED;
                } else {
                    this.vx = 0;
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Boundary checks
                if (this.x < WALL_X) {
                    this.x = WALL_X;
                }
                if (this.x + this.width > WALL_X + WALL_WIDTH) {
                    this.x = WALL_X + WALL_WIDTH - this.width;
                }
            }

            jump() {
                if (this.jumpsUsed < MAX_JUMPS) {
                    this.vy = JUMP_FORCE; 
                    this.onGround = false;
                    this.jumpsUsed++;
                }
            }
            
            // Fire Laser Method
            fireLaser() {
                if (this.currentTool === 'laser_gun' && this.laserCooldown <= 0) {
                    const laserX = this.x + this.width / 2 - 2; // Center of player
                    const laserY = this.y; // Top of player
                    
                    gameState.lasers.push(new Laser(laserX, laserY));
                    
                    this.laserCooldown = 8; // Small cooldown to prevent too much spam
                    updateToolDisplay(); // Update UI
                }
            }

            draw() {
                // Flashing Logic: Blink every 5 frames if flashTimer is active
                if (this.flashTimer > 0 && Math.floor(this.flashTimer / 5) % 2 === 0) {
                    ctx.globalAlpha = 0.5; // Make player half transparent when flashing
                } else {
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.width, this.height);
                
                ctx.globalAlpha = 1.0; // Reset alpha for other drawings
            }
        }

        class Platform {
            constructor(level, x, y_absolute, w, h, type = 'static', speed = 0) {
                this.x = x;
                this.y = y_absolute; 
                this.w = w;
                this.h = h;
                this.type = type;
                this.speed = speed;
                this.color = '#ff416c'; 
                this.startY = y_absolute;
                this.startX = x; 

                if (type.includes('moving')) {
                    this.color = '#4dffa6';
                }
            }

            update() {
                if (this.type === 'moving-h') {
                    this.x += this.speed;
                    if (this.x < WALL_X || this.x + this.w > WALL_X + WALL_WIDTH) {
                        this.speed *= -1;
                    }
                } else if (this.type === 'moving-v') {
                    this.y += this.speed;
                    if (this.y < this.startY - 100 || this.y > this.startY + 100) {
                        this.speed *= -1;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.w, this.h);
            }
        }

        class Obstacle {
            constructor(x, y_absolute, w, h, type = 'sweeper', speed = 0) {
                this.x = x;
                this.y = y_absolute; 
                this.w = w;
                this.h = h;
                this.type = type;
                this.speed = speed;
                this.color = '#ff0000';
                this.startY = y_absolute; 
                this.startX = x;
                this.toRemove = false; 
            }

            update() {
                if (this.type === 'sweeper') {
                    this.x += this.speed;
                    if (this.x < WALL_X || this.x + this.w > WALL_X + WALL_WIDTH) {
                        this.speed *= -1;
                    }
                } else if (this.type === 'bouncer') {
                    this.y += this.speed;
                    if (this.y < this.startY - 150 || this.y > this.startY + 150) {
                        this.speed *= -1;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.w, this.h);
                
                ctx.fillStyle = '#ff9999';
                ctx.fillRect(this.x, this.y - scrollY, this.w, 3);
                ctx.fillRect(this.x, this.y - scrollY + this.h - 3, this.w, 3);
            }
        }
        
        class BaseMushroom {
            constructor(x, y_absolute, parentPlatform, capColor, dotColor) {
                this.x = x;
                this.y = y_absolute; 
                this.w = 15;
                this.h = 15;
                this.toRemove = false;
                this.platform = parentPlatform;
                this.speed = 0.8; 
                this.capColor = capColor;
                this.dotColor = dotColor;
                this.minX = this.platform.x + 5;
                this.maxX = this.platform.x + this.platform.w - this.w - 5;
            }

            update() {
                this.minX = this.platform.x + 5;
                this.maxX = this.platform.x + this.platform.w - this.w - 5;

                this.x += this.speed;

                if (this.x < this.minX || this.x > this.maxX) {
                    this.speed *= -1;
                }
                
                if (this.platform.type.includes('moving')) {
                    this.y = this.platform.y - this.h;
                }
            }

            draw() {
                const screenY = this.y - scrollY;
                
                // Base/Stem color (Dark Grey)
                ctx.fillStyle = '#333333'; 
                ctx.fillRect(this.x + this.w/2 - 3, screenY + 5, 6, 10);
                
                // Cap color 
                ctx.fillStyle = this.capColor; 
                ctx.beginPath();
                ctx.arc(this.x + this.w / 2, screenY + 5, this.w / 2, Math.PI, 0, false);
                ctx.closePath();
                ctx.fill();

                // Add small spots 
                ctx.fillStyle = this.dotColor;
                ctx.fillRect(this.x + 3, screenY + 2, 2, 2);
                ctx.fillRect(this.x + 10, screenY + 2, 2, 2);
            }
        }
        
        // Poison Mushroom (Red)
        class PoisonMushroom extends BaseMushroom {
            constructor(x, y_absolute, parentPlatform) {
                super(x, y_absolute, parentPlatform, '#CC0000', '#FFFFFF');
            }
        }
        
        // Antidote Mushroom (Green)
        class AntidoteMushroom extends BaseMushroom {
            constructor(x, y_absolute, parentPlatform) {
                super(x, y_absolute, parentPlatform, '#34D399', '#FFFFFF'); // Emerald Green
            }
        }
        
        // Tool Class
        class Tool {
            constructor(x, y_absolute, type, platform = null) {
                this.x = x;
                this.y = y_absolute;
                this.w = 15;
                this.h = 15;
                this.width = 15; // Keep for player-side collision logic if needed
                this.height = 15;
                this.type = type;
                this.color = '#00FFFF'; // Cyan for laser gun
                this.toRemove = false;
                this.platform = platform;
                this.relativeX = x - (platform ? platform.x : 0);
            }

            update() {
                if (this.platform) {
                    this.x = this.platform.x + this.relativeX;
                    this.y = this.platform.y - this.h - 2;
                }
            }

            draw() {
                // Draw as a triangle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.w / 2, this.y - scrollY); // Top center
                ctx.lineTo(this.x, this.y - scrollY + this.h); // Bottom left
                ctx.lineTo(this.x + this.w, this.y - scrollY + this.h); // Bottom right
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Laser Class
        class Laser {
            constructor(x, y_absolute) {
                this.x = x;
                this.y = y_absolute;
                this.width = 4;
                this.height = 20;
                this.vy = -50; 
                this.color = '#FFFF00'; 
                this.toRemove = false;
            }
            
            update() {
                this.y += this.vy;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.width, this.height);
            }
        }


        // --- Game Logic Functions (Omitted for brevity, assuming no change needed) ---
        
        function generateNewPlatforms(startY, customBuffer) {
            let currentY = startY;
            const buffer = customBuffer || GENERATION_BUFFER_Y;
            const targetY = currentY - buffer;

            while (currentY > targetY) {
                const yGap = Math.floor(Math.random() * (PLATFORM_GAP_MAX - PLATFORM_GAP_MIN) + PLATFORM_GAP_MIN);
                currentY -= yGap;

                // Determine platform properties
                const w = Math.floor(Math.random() * (PLATFORM_WIDTH_MAX - PLATFORM_WIDTH_MIN) + PLATFORM_WIDTH_MIN);
                const maxX = WALL_X + WALL_WIDTH - w;
                const x = Math.floor(Math.random() * (maxX - WALL_X) + WALL_X);
                const h = 10;
                
                // Randomly decide platform type
                const rand = Math.random();
                let type = 'static';
                let speed = 0;
                if (rand > 0.7) {
                    if (Math.random() > 0.5) {
                        type = 'moving-h';
                        speed = Math.random() < 0.5 ? 1.5 : -1.5;
                    } else {
                        type = 'moving-v';
                        speed = Math.random() < 0.5 ? 1 : -1;
                    }
                }

                // Push platform
                const p = new Platform(0, x, currentY, w, h, type, speed);
                gameState.platforms.push(p);

                // 1. Tool Generation
                if (Math.random() < 0.15 && (!gameState.player || gameState.player.currentTool === 'none')) {
                    const toolW = 15;
                    const toolH = 15;
                    const toolX = p.x + (p.w / 2) - (toolW / 2);
                    const toolY = p.y - toolH - 2;
                    gameState.tools.push(new Tool(toolX, toolY, 'laser_gun', p));
                }

                // 2. Poison Mushroom Generation (Red, 15% chance)
                if (p.type === 'static' && Math.random() < 0.15 && p.w > 40) {
                    const mushW = 15;
                    const mushH = 15;
                    const mushX = p.x + (p.w / 2) - (mushW / 2); // Start in center
                    const mushY = p.y - mushH;
                    gameState.mushrooms.push(new PoisonMushroom(mushX, mushY, p));
                }
                
                // 3. Antidote Mushroom Generation (Green, 8% chance)
                if (p.type === 'static' && Math.random() < 0.08 && p.w > 40) {
                    const mushW = 15;
                    const mushH = 15;
                    const mushX = p.x + (p.w / 2) - (mushW / 2);
                    const mushY = p.y - mushH;
                    gameState.antidotes.push(new AntidoteMushroom(mushX, mushY, p));
                }

                // 4. Obstacle Generation Logic (between platforms)
                if (Math.random() < 0.25) {
                    const obsW = Math.floor(Math.random() * 40) + 20;
                    const obsH = 20;
                    const safeMargin = 10;
                    const obsYMin = currentY + obsH + safeMargin;
                    const obsYMax = currentY + yGap - safeMargin - 30;
                    
                    if (obsYMax > obsYMin) {
                        const obsY = Math.floor(Math.random() * (obsYMax - obsYMin) + obsYMin);
                        const obsXMax = WALL_X + WALL_WIDTH - obsW;
                        const obsX = Math.floor(Math.random() * (obsXMax - WALL_X) + WALL_X);
                        
                        const obsType = Math.random() > 0.5 ? 'sweeper' : 'bouncer';
                        const obsSpeed = obsType === 'sweeper' ? (Math.random() < 0.5 ? 2.5 : -2.5) : (Math.random() < 0.5 ? 1.5 : -1.5);

                        gameState.obstacles.push(new Obstacle(obsX, obsY, obsW, obsH, obsType, obsSpeed));
                    }
                }

                highestPlatformY = Math.min(highestPlatformY, currentY);
            }
        }

        function loadInitialLevels() {
            gameState.platforms = [];
            gameState.obstacles = [];
            gameState.tools = [];
            gameState.lasers = [];
            gameState.mushrooms = [];
            gameState.antidotes = [];
            
            highestPlatformY = canvas.height;

            // Create starting platform
            gameState.platforms.push(new Platform(0, WALL_X, canvas.height - 30, WALL_WIDTH, 30, 'static'));

            // Set player position
            gameState.player = new Player(canvas.width / 2 - 10, canvas.height - 60);
            gameState.player.vy = 0;
            gameState.player.currentTool = 'none';
            gameState.player.poisonHits = 0;
            gameState.player.flashTimer = 0;

            // Generate initial set of platforms to fill the screen and beyond
            generateNewPlatforms(canvas.height - 100, canvas.height + GENERATION_BUFFER_Y);

            // Reset scroll and score
            scrollY = 0;
            distanceClimbed = 0;
            updateLevelDisplay();
            updateToolDisplay();
            updatePoisonDisplay();
            
        }

        function checkCollision(obj1, obj2) {
            // obj1 has width/height, obj2 has w/h
            return (
                obj1.x < obj2.x + obj2.w &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.h &&
                obj1.y + obj1.height > obj2.y
            );
        }

        function updateGame() {
            if (gameState.isGameOver) return;

            gameState.player.update();

            const discardThresholdY = scrollY + canvas.height + 100;

            // Update and Filter Entities
            gameState.platforms.forEach(p => p.update());
            gameState.platforms = gameState.platforms.filter(p => p.y < discardThresholdY);

            gameState.tools.forEach(t => t.update());
            
            gameState.obstacles.forEach(o => o.update());
            gameState.obstacles = gameState.obstacles.filter(o => !o.toRemove && o.y < discardThresholdY);
            
            gameState.mushrooms.forEach(m => m.update());
            gameState.mushrooms = gameState.mushrooms.filter(m => !m.toRemove && m.y < discardThresholdY);

            gameState.antidotes.forEach(a => a.update());
            gameState.antidotes = gameState.antidotes.filter(a => !a.toRemove && a.y < discardThresholdY);
            
            gameState.lasers.forEach(l => l.update());
            gameState.lasers = gameState.lasers.filter(l => !l.toRemove && l.y > scrollY - 20); // Laser removes itself if it goes far off-screen upwards

            // --- Collision Detection ---
            const player = gameState.player;
            player.onGround = false;

            // Platform collision (Solid: collisions on all sides)
            gameState.platforms.forEach(p => {
                // Check for intersection
                if (player.x < p.x + p.w &&
                    player.x + player.width > p.x &&
                    player.y < p.y + p.h &&
                    player.y + player.height > p.y) {

                    const prevPlayerX = player.x - player.vx;
                    const prevPlayerY = player.y - player.vy;
                    const prevPlatformX = p.type === 'moving-h' ? p.x - p.speed : p.x;
                    const prevPlatformY = p.type === 'moving-v' ? p.y - p.speed : p.y;

                    // Determine which side the collision happened on based on previous positions
                    
                    // Collision from TOP (Player landing)
                    if (prevPlayerY + player.height <= prevPlatformY + 1) {
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                        player.jumpsUsed = 0;
                        // Apply platform velocity
                        if (p.type === 'moving-h') player.x += p.speed;
                        if (p.type === 'moving-v') player.y += p.speed;
                    }
                    // Collision from BOTTOM (Player hitting head)
                    else if (prevPlayerY >= prevPlatformY + p.h - 1) {
                        player.y = p.y + p.h;
                        player.vy = Math.max(0, player.vy); // Stop upward momentum
                    }
                    // Collision from LEFT
                    else if (prevPlayerX + player.width <= prevPlatformX + 1) {
                        player.x = p.x - player.width;
                        player.vx = 0;
                    }
                    // Collision from RIGHT
                    else if (prevPlayerX >= prevPlatformX + p.w - 1) {
                        player.x = p.x + p.w;
                        player.vx = 0;
                    }
                }
            });

            // Player falls off screen (Game Over condition)
            if (player.y - scrollY > canvas.height) {
                gameOver('You fell into the abyss');
                return;
            }

            // Player hits ceiling (bounce down slightly)
            const ceilingY = highestPlatformY - 50; 
            if (player.y < ceilingY && scrollY > 0) {
                player.y = ceilingY;
                player.vy = 0; 
            }
            
            // Obstacle collision
            gameState.obstacles.forEach(o => {
                if (checkCollision(player, o) && player.flashTimer <= 0) {
                    gameOver('You were caught by a dangerous hazard');
                    return;
                }
            });

            // Tool collision
            gameState.tools.forEach(tool => {
                if (checkCollision(player, tool)) {
                    player.currentTool = tool.type; // 'laser_gun'
                    player.laserCooldown = 0;
                    tool.toRemove = true;
                    updateToolDisplay();
                }
            });
            gameState.tools = gameState.tools.filter(t => !t.toRemove);


            // Poison Mushroom collision
            gameState.mushrooms.forEach(m => {
                if (checkCollision(player, m)) {
                    if (player.poisonHits < 3) {
                        player.poisonHits++;
                        player.flashTimer = 50; // Flash for visual feedback
                        updatePoisonDisplay();
                    }
                    m.toRemove = true;
                    if (player.poisonHits >= 3) {
                        gameOver('You consumed too much poison!');
                        return;
                    }
                }
            });
            gameState.mushrooms = gameState.mushrooms.filter(m => !m.toRemove);
            
            // Antidote Mushroom collision
            gameState.antidotes.forEach(a => {
                if (checkCollision(player, a)) {
                    if (player.poisonHits > 0) {
                        player.poisonHits--;
                        player.flashTimer = 30; 
                        updatePoisonDisplay();
                    }
                    a.toRemove = true;
                }
            });
            gameState.antidotes = gameState.antidotes.filter(a => !a.toRemove);


            // Laser collision with Obstacle
            gameState.lasers.forEach(laser => {
                gameState.obstacles.forEach(obstacle => {
                    if (checkCollision(laser, obstacle)) {
                        laser.toRemove = true;
                        obstacle.toRemove = true; 
                    }
                });
            });


            // --- Screen Scrolling & Generation ---
            // If player is high on the screen, adjust scroll (center the player vertically)
            const playerScreenY = player.y - scrollY;
            const centerHeight = canvas.height * 0.4; // 40% up from the bottom
            
            if (playerScreenY < centerHeight) {
                scrollY = player.y - centerHeight;
            }

            // Update distance climbed (score)
            distanceClimbed = Math.max(distanceClimbed, canvas.height - player.y);
            updateLevelDisplay();


            // Platform generation when player climbs higher
            if (scrollY < highestPlatformY + GENERATION_BUFFER_Y) {
                generateNewPlatforms(highestPlatformY, GENERATION_BUFFER_Y);
            }
        }

        function drawGame() {
            if (gameState.isGameOver) {
                // Draw last frame of game before message box
                drawEntities();
            } else {
                requestAnimationFrame(drawGame);
                updateGame();
                drawEntities();
            }
        }

        function drawEntities() {
             // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw boundaries (walls)
            ctx.fillStyle = '#3c004d'; // Purple walls
            ctx.fillRect(0, 0, WALL_X, canvas.height); // Left wall
            ctx.fillRect(WALL_X + WALL_WIDTH, 0, WALL_X, canvas.height); // Right wall

            // Draw all entities
            gameState.platforms.forEach(p => p.draw());
            gameState.tools.forEach(t => t.draw());
            gameState.obstacles.forEach(o => o.draw());
            gameState.mushrooms.forEach(m => m.draw());
            gameState.antidotes.forEach(a => a.draw());
            gameState.lasers.forEach(l => l.draw());

            // Draw player
            if (gameState.player) {
                gameState.player.draw();
            }
        }

        function updateLevelDisplay() {
            levelDisplay.textContent = `Climb: ${distanceClimbed.toFixed(0)} meters`;
        }
        
        function updateToolDisplay() {
            toolDisplay.textContent = `Tool: ${gameState.player.currentTool === 'laser_gun' ? 'LASER (X)' : 'None'}`;
        }
        
        function updatePoisonDisplay() {
             poisonDisplay.textContent = `Poison: ${gameState.player.poisonHits} / 3`;
             if (gameState.player.poisonHits > 0) {
                 poisonDisplay.classList.remove('text-red-500', 'text-gray-400');
                 poisonDisplay.classList.add(gameState.player.poisonHits === 3 ? 'text-red-600' : 'text-yellow-500');
             } else {
                 poisonDisplay.classList.remove('text-red-600', 'text-yellow-500');
                 poisonDisplay.classList.add('text-gray-400');
             }
        }

        async function gameOver(reason) {
            gameState.isGameOver = true;
            
            // Automatically save the score
            const finalName = playerNameInput.value.trim() || displayPlayerName.textContent;
            await saveScore(finalName, distanceClimbed);

            // Wait a moment for the user to see the reason then restart
            setTimeout(() => {
                resetGame();
            }, 1000);
        }

        function resetGame() {
            loadInitialLevels();
            gameState.isGameOver = false;
            drawGame();
        }

        // --- Event Handlers (Unchanged) ---
        
        // Key press handlers
        document.addEventListener('keydown', (e) => {
            if (gameState.isGameOver) return;
            
            if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') {
                if (!gameState.keys['ArrowUp']) {
                    gameState.player.jump();
                }
                gameState.keys['ArrowUp'] = true;
            } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                gameState.keys['ArrowLeft'] = true;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                gameState.keys['ArrowRight'] = true;
            } else if (e.key.toLowerCase() === 'x') {
                // Fire laser on press
                gameState.player.fireLaser();
                gameState.keys['x'] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === ' ' || e.key.toLowerCase() === 'w') {
                gameState.keys['ArrowUp'] = false;
            } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                gameState.keys['ArrowLeft'] = false;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                gameState.keys['ArrowRight'] = false;
            } else if (e.key.toLowerCase() === 'x') {
                 gameState.keys['x'] = false;
            }
        });

        // Touch control handlers
        const setupButtonEvents = (button, key, isHoldAction = false) => {
            const pressEvent = () => {
                if (gameState.isGameOver) return;
                if (key === 'ArrowUp') {
                    if (!gameState.keys['ArrowUp']) {
                        gameState.player.jump();
                    }
                } else if (key === 'x') {
                    if (!gameState.keys['x']) {
                        gameState.player.fireLaser();
                    }
                }
                gameState.keys[key] = true;
            };

            const releaseEvent = () => {
                gameState.keys[key] = false;
            };

            button.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                pressEvent();
            }, { passive: false });
            
            button.addEventListener('touchend', releaseEvent);
            button.addEventListener('mousedown', pressEvent);
            button.addEventListener('mouseup', releaseEvent);
            button.addEventListener('mouseleave', releaseEvent); // Important for mouse drag off
            
        };

        // --- Leaderboard & Submission Handlers (Updated) ---
        
        updateNameButton.onclick = () => {
            const newName = playerNameInput.value.trim();
            if (newName) {
                savePlayerName(newName);
                displayPlayerName.textContent = newName;
                updateNameButton.textContent = 'Saved!';
                setTimeout(() => { updateNameButton.textContent = 'Update'; }, 1500);
            }
        };

        viewLeaderboardButton.onclick = () => {
            setupLeaderboardListener(); // Start listening for updates
            leaderboardModal.style.display = 'block';
        };

        closeLeaderboardButton.onclick = () => {
            leaderboardModal.style.display = 'none';
            // Stop ALL listeners on the best scores path when the modal is closed
            if (db) {
                off(getBestScoresRef()); 
            }
        };
        
        // --- Initialization (Updated) ---

        const startGame = () => {
            // Initial resize
            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                if (!gameState.isGameOver) {
                    // Recalculate positions if necessary, or just rely on next frame
                }
            });

            // Setup controls
            const touchLeft = document.getElementById('touchLeft');
            const touchRight = document.getElementById('touchRight');
            const touchJump = document.getElementById('touchJump');
            const touchFire = document.getElementById('touchFire');
            
            setupButtonEvents(touchLeft, 'ArrowLeft');
            setupButtonEvents(touchRight, 'ArrowRight');
            setupButtonEvents(touchJump, 'ArrowUp'); // Jump/Float
            setupButtonEvents(touchFire, 'x', true); // Fire is an instant action + hold for rapid fire

            // Start the game
            resetGame();
        }

        /**
         * Initializes Firebase authentication and then calls startGame().
         */
        const initGame = async () => {
            // Load or generate name
            let savedName = loadPlayerName();
            if (!savedName) {
                savedName = generateRandomName();
                savePlayerName(savedName);
            }
            playerNameInput.value = savedName;
            displayPlayerName.textContent = savedName;

            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    
                    // 1. Initialize App
                    app = initializeApp(firebaseConfig);
                    
                    // 2. Initialize Realtime Database
                    db = getDatabase(app); 
                    
                    // 3. Initialize Auth and sign in anonymously
                    auth = getAuth(app);
                    await signInAnonymously(auth);
                    
                    // On success, update userId from 'anon' to the persistent UID
                    userId = auth.currentUser?.uid || 'anon';
                    console.log("Firebase Auth successful. User ID:", userId);
                    console.log("Realtime Database connected at:", firebaseConfig.databaseURL);

                } else {
                    console.warn("Firebase config not available. Starting game without database/leaderboard.");
                }
            } catch (e) {
                // If this fails, userId remains 'anon', and the saveScore check will block the save.
                console.error("Critical Firebase error during initialization/auth:", e); 
            }
            
            // ALWAYS start the game loop after attempting Firebase init
            startGame(); 
        };

        // Call the initialization function immediately after the script loads
        initGame();
    </script>
</body>
</html>
