<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Climb</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            width: 100%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            background-color: #1a1a2e; /* Dark theme for the tower */
            border: 4px solid #3c004d;
        }
        canvas {
            display: block;
            background: linear-gradient(to bottom, #10001f 0%, #1a1a2e 100%);
        }
        .controls {
            padding: 16px;
            text-align: center;
            background-color: #1a1a2e;
            border-top: 1px solid #3c004d;
        }
        .controls p {
            margin: 4px 0;
            font-size: 0.9rem;
            color: #999;
        }
        .control-key {
            display: inline-block;
            background-color: #3c004d;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: bold;
            box-shadow: 0 2px #28003a;
        }
        
        /* Message Box / Modals (Game Over & Leaderboard) - MODIFIED FROM V8 */
        .message-box {
            position: fixed; /* Use fixed for proper overlay */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(44, 44, 60, 0.98);
            border: 3px solid #ff416c;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            min-width: 280px;
            max-width: 90%;
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.5);
            display: none; /* Initially hidden */
        }
        .message-box h2 {
            font-size: 1.8rem;
            color: #ff416c;
            margin-bottom: 10px;
        }
        .message-box p {
            margin-bottom: 20px;
            color: #ccc;
        }
        
        /* Buttons in Message Box */
        .message-box button {
            background-color: #ff416c;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        .message-box button:hover {
            background-color: #e03a5e;
        }
        .message-box button:active {
            transform: scale(0.98);
        }

        /* --- Leaderboard Specific Styles (NEW FROM V8) --- */
        #leaderboardModal h2 {
            color: #4dffa6; /* Green for leaderboard title */
        }
        
        #leaderboardContent {
            max-height: 300px; 
            overflow-y: auto;
            margin-top: 20px;
            padding-right: 10px;
            border-top: 1px solid #3c004d;
            padding-top: 15px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px dashed rgba(153, 153, 153, 0.3);
            font-size: 1rem;
        }
        
        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            font-weight: bold;
            color: #4dffa6; 
            width: 30px;
            font-size: 1.2rem;
        }

        .leaderboard-name {
            flex-grow: 1;
            color: #e0e0e0;
            text-align: left;
            margin-left: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #ffeb3b; 
            min-width: 60px;
            text-align: right;
        }
        /* --- Touch Controls --- */
        #touchControls {
            display: flex;
            justify-content: space-between;
            padding: 1rem;
            background-color: #0d0d1a;
        }

        .touch-button {
            width: 70px;
            height: 70px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px rgba(0, 0, 0, 0.4);
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            transition: transform 0.1s, opacity 0.1s;
            opacity: 0.85; 
        }
        .touch-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px rgba(0, 0, 0, 0.4);
            opacity: 1;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="gameCanvas" width="500" height="650"></canvas>
        <div class="controls">
            <p>Controls: Move <span class="control-key">←</span> <span class="control-key">→</span> Jump/Float <span class="control-key">↑</span></p>
            <p>Fire Laser with <span class="control-key">X</span></p> 
            <p id="level-display" class="font-bold text-lg text-fuchsia-400 mt-2"></p>
            <div class="flex justify-center space-x-6">
                <p id="tool-display" class="font-bold text-lg text-cyan-400"></p>
                <p id="poison-display" class="font-bold text-lg text-red-500"></p>
            </div>
            <button id="viewLeaderboardButton" class="mt-4 px-4 py-2 bg-purple-700 hover:bg-purple-600 text-white font-bold rounded-lg shadow-lg transition duration-150">View Leaderboard</button>
        </div>

        <div id="touchControls">
            <div class="flex space-x-4">
                <button id="touchLeft" class="touch-button bg-blue-700">←</button>
                <button id="touchRight" class="touch-button bg-blue-700">→</button>
            </div>
            <div class="flex space-x-4">
                <button id="touchFire" class="touch-button bg-red-600">Fire (X)</button>
                <button id="touchJump" class="touch-button bg-green-600">Jump (↑)</button>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <h2 id="messageTitle"></h2>
        <p id="messageText"></p>
        <div id="scoreSubmitForm" class="hidden">
            <label for="playerName" class="block mb-2 text-sm font-medium text-gray-300">Enter Your Name:</label>
            <input type="text" id="playerName" maxlength="15" placeholder="Player Name" class="mb-4 w-full p-2 bg-gray-700 border border-purple-500 rounded text-white text-center">
            <button id="saveScoreButton" class="w-full bg-fuchsia-600 hover:bg-fuchsia-500">Save Score & Restart</button>
            <button id="restartWithoutSaveButton" class="mt-2 w-full bg-gray-600 hover:bg-gray-500">Restart Without Saving</button>
        </div>
        <button id="restartButton" class="hidden">Try Again</button>
    </div>

    <div id="leaderboardModal" class="message-box">
        <h2 class="text-fuchsia-400">Hall of Ascent</h2>
        <div id="leaderboardContent">
            <p class="text-center text-gray-400">Loading scores... (Max 10)</p>
        </div>
        <button id="closeLeaderboardButton" class="mt-4 bg-purple-700 hover:bg-purple-600">Close</button>
    </div>

    <script type="module">
        // MODIFIED IMPORTS: Using Realtime Database (RTDB) from V8
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"; 
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue, off, query, orderByChild, limitToLast, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Firebase Configuration and Initialization (FROM V8) ---
        // 1. SET THE APP ID HERE
        const appId = 'games-d836d'; // Your app ID / Folder name
        
        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDyMbSVjBTVStyRXOEo38IeMcM4LWTdJ-I",
            authDomain: "games-d836d.firebaseapp.com", 
            databaseURL: "https://games-d836d-default-rtdb.firebaseio.com",
            projectId: "games-d836d",
            storageBucket: "games-d836d.firebasestorage.app",
            messagingSenderId: "228157907811",
            appId: "1:228157907811:web:c2a536b3b3bb6ade5e6956"
        };
        
        // --- GLOBAL VARIABLES FOR FIREBASE (FROM V8) ---
        let app = null;
        let auth = null;
        let db = null;
        let userId = 'anon';

        // --- Local Storage Key (NEW FROM V8) ---
        const STORAGE_KEY_NAME = 'climberPlayerName';
        
        // --- Game Setup and Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game Mechanics Constants
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = -15;
        const GRAVITY = 0.6;
        const WALL_X = 50;
        const WALL_WIDTH = canvas.width - 100;
        
        // Kirby Jump Constants
        const MAX_JUMPS = 2; 
        const FLOAT_GRAVITY = 0.2; 
        const FLOAT_FALL_CAP = 4; 
        
        // Platform Generation Constants
        const PLATFORM_GAP_MIN = 80; 
        const PLATFORM_GAP_MAX = 140; 
        const PLATFORM_WIDTH_MIN = 70;
        const PLATFORM_WIDTH_MAX = 200;
        const GENERATION_BUFFER_Y = 450; 

        // State variables for infinite generation
        let highestPlatformY = 0; 
        let scrollY = 0; 
        let distanceClimbed = 0; 

        let gameState = {
            player: null,
            platforms: [],
            obstacles: [], 
            tools: [], 
            mushrooms: [], // Poison mushrooms
            antidotes: [], // Antidote mushrooms (NEW)
            lasers: [], 
            isGameOver: false,
            keys: {}
        };

        const levelDisplay = document.getElementById('level-display');
        const toolDisplay = document.getElementById('tool-display'); 
        const poisonDisplay = document.getElementById('poison-display'); 
        
        // Game Over/Submission DOM elements (UPDATED FROM V8)
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton'); 

        const scoreSubmitForm = document.getElementById('scoreSubmitForm');
        const playerNameInput = document.getElementById('playerName');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const restartWithoutSaveButton = document.getElementById('restartWithoutSaveButton');
        
        // Leaderboard DOM elements (NEW FROM V8)
        const viewLeaderboardButton = document.getElementById('viewLeaderboardButton');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const leaderboardContent = document.getElementById('leaderboardContent');
        const closeLeaderboardButton = document.getElementById('closeLeaderboardButton');
        

        // --- Local Storage Helpers (NEW FROM V8) ---
        const loadPlayerName = () => {
            try {
                return localStorage.getItem(STORAGE_KEY_NAME);
            } catch (e) {
                console.error("Local storage access denied:", e);
                return null;
            }
        };

        const savePlayerName = (name) => {
            try {
                localStorage.setItem(STORAGE_KEY_NAME, name);
            } catch (e) {
                console.error("Local storage write failed:", e);
            }
        };

        // --- Name Generation Logic (NEW FROM V8) ---
        const ADJECTIVES = ['Sly', 'Swift', 'Brave', 'Crimson', 'Azure', 'Iron', 'Golden', 'Mystic', 'Silent', 'Wily', 'Cosmic', 'Shadow', 'Peak'];
        const NOUNS = ['Climber', 'Tower', 'Ascender', 'Phantom', 'Jumper', 'Racer', 'Bot', 'Star', 'Hawk', 'Shroom', 'Wisp', 'Vortex', 'Orb'];

        /**
         * Generates a random player name (e.g., SwiftRacer42).
         * @returns {string}
         */
        const generateRandomName = () => {
            const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
            const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
            const num = Math.floor(Math.random() * 99) + 1;
            return `${adj}${noun}${num}`;
        };


        // --- Firebase/Leaderboard Logic (NEW FROM V8) ---

        /**
         * Gets the reference to the public 'user_best_scores' path in Realtime Database.
         * This node stores only the high score for each unique user ID.
         */
        const getBestScoresRef = () => {
            return ref(db, `artifacts/${appId}/public/data/user_best_scores`);
        };

        /**
         * Saves the current score to Realtime Database using runTransaction.
         * This ensures the score is only updated if the new score is higher than the existing one.
         * @param {string} name 
         * @param {number} score 
         */
        const saveScore = async (name, score) => {
            if (!db) {
                console.warn("Database not initialized. Cannot save score. Check 'initGame' in the console for 'Critical Firebase error'.");
                return;
            }
            
            if (userId === 'anon') {
                 console.warn("User not authenticated. Cannot save score. Please ensure Anonymous Sign-in is enabled in your Firebase project (Authentication -> Sign-in method tab).");
                 return;
            }

            const finalScore = Math.floor(score);
            // Reference to this specific user's record
            const scoreRef = ref(db, `artifacts/${appId}/public/data/user_best_scores/${userId}`);

            try {
                const { committed, snapshot } = await runTransaction(scoreRef, (currentData) => {
                    // currentData will be null if no record exists for this user ID
                    if (currentData === null || finalScore > currentData.score) {
                        // If no data exists, or new score is better, return the new data
                        return {
                            name: name || 'Anonymous Climber',
                            score: finalScore, 
                            timestamp: Date.now(),
                            userId: userId, 
                        };
                    } else {
                        // Score is not higher, abort transaction by returning undefined
                        return; 
                    }
                });
                
                if (committed) {
                    console.log(`Score ${finalScore} saved/updated successfully by ${name}.`);
                } else {
                    console.log(`Score ${finalScore} was not a new high score for ${name}. Save skipped.`);
                }
            } catch (e) {
                console.error("Error running score transaction in RTDB: ", e);
            }
        };

        /**
         * Renders the leaderboard content based on the fetched scores array.
         * @param {Array<Object>} scores
         */
        const renderLeaderboard = (scores) => {
            let html = '<div class="leaderboard-item font-bold text-gray-400 border-none"><span class="leaderboard-rank">#</span><span class="leaderboard-name">Player</span><span class="leaderboard-score">Meters</span></div>';
            
            if (scores.length === 0) {
                html += '<p class="text-center text-gray-400 py-4">No scores recorded yet!</p>';
            } else {
                // Scores are already sorted descending by the RTDB query
                scores.forEach((score, index) => {
                    html += `
                        <div class="leaderboard-item">
                            <span class="leaderboard-rank">${index + 1}.</span>
                            <span class="leaderboard-name">${score.name}</span>
                            <span class="leaderboard-score">${score.score}</span>
                        </div>
                    `;
                });
            }
            leaderboardContent.innerHTML = html;
        };

        /**
         * Sets up the real-time listener for the leaderboard using RTDB.
         * Now queries the 'user_best_scores' node and limits to the top 10.
         */
        const setupLeaderboardListener = () => {
            if (!db) {
                 leaderboardContent.innerHTML = '<p class="text-center text-red-400 py-4">Database not available.</p>';
                 return;
            }

            // Reference to the best scores path
            const bestScoresRef = getBestScoresRef();

            // Query to order by score (ascending by default) and limit to the last 10 (highest scores)
            const leaderboardQuery = query(
                bestScoresRef,
                orderByChild('score'),
                limitToLast(10) // Limit to top 10 scores
            );
            
            // Start listening
            onValue(leaderboardQuery, (snapshot) => {
                const scoresObject = snapshot.val();
                let scores = [];

                if (scoresObject) {
                    // Convert object of scores into an array
                    for (let key in scoresObject) {
                        scores.push(scoresObject[key]);
                    }
                }
                
                // Sort them locally to ensure DESCENDING score order for display.
                scores.sort((a, b) => b.score - a.score); 

                renderLeaderboard(scores);
            }, (error) => {
                console.error("Error fetching leaderboard: ", error);
                leaderboardContent.innerHTML = '<p class="text-center text-red-400 py-4">Error loading scores. Check console for details.</p>';
            });
        };


        // --- Game Classes --- 

        class Player {
            constructor(x, y) {
                this.width = 20;
                this.height = 30;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.jumpsUsed = 0; 
                this.color = '#ffeb3b';
                
                // Tool properties
                this.currentTool = 'none';
                this.laserCooldown = 0; 

                // Poison properties
                this.poisonHits = 0; // 3 hits max
                this.flashTimer = 0; // For player visual feedback
                
                // NEW: Anti-bug flag is initialized in loadInitialLevels/resetGame
            }

            update() {
                // Update cooldown and flashing timer
                if (this.laserCooldown > 0) {
                    this.laserCooldown--;
                }
                if (this.flashTimer > 0) {
                    this.flashTimer--;
                }
                updatePoisonDisplay(); // Update UI

                // Apply Kirby Float/Gravity Logic
                const isHoldingJump = gameState.keys['ArrowUp'];
                const isInAir = !this.onGround;

                if (isInAir && this.jumpsUsed === MAX_JUMPS && isHoldingJump) {
                    this.vy += FLOAT_GRAVITY;
                    this.vy = Math.min(this.vy, FLOAT_FALL_CAP); 
                } else {
                    this.vy += GRAVITY;
                }
                
                // Horizontal movement
                if (gameState.keys['ArrowLeft']) {
                    this.vx = -PLAYER_SPEED;
                } else if (gameState.keys['ArrowRight']) {
                    this.vx = PLAYER_SPEED;
                } else {
                    this.vx = 0;
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Boundary checks
                if (this.x < WALL_X) {
                    this.x = WALL_X;
                }
                if (this.x + this.width > WALL_X + WALL_WIDTH) {
                    this.x = WALL_X + WALL_WIDTH - this.width;
                }
            }

            jump() {
                if (this.jumpsUsed < MAX_JUMPS) {
                    this.vy = JUMP_FORCE; 
                    this.onGround = false;
                    this.jumpsUsed++;
                }
            }
            
            // Fire Laser Method
            fireLaser() {
                if (this.currentTool === 'laser_gun' && this.laserCooldown <= 0) {
                    const laserX = this.x + this.width / 2 - 2; // Center of player
                    const laserY = this.y; // Top of player
                    
                    gameState.lasers.push(new Laser(laserX, laserY));
                    
                    this.laserCooldown = 15; // Small cooldown to prevent too much spam
                    updateToolDisplay(); // Update UI
                }
            }

            draw() {
                // Flashing Logic: Blink every 5 frames if flashTimer is active
                if (this.flashTimer > 0 && Math.floor(this.flashTimer / 5) % 2 === 0) {
                    ctx.globalAlpha = 0.5; // Make player half transparent when flashing
                } else {
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.width, this.height);
                
                ctx.globalAlpha = 1.0; // Reset alpha for other drawings
            }
        }

        class Platform {
            constructor(level, x, y_absolute, w, h, type = 'static', speed = 0) {
                this.x = x;
                this.y = y_absolute; 
                this.w = w;
                this.h = h;
                this.type = type;
                this.speed = speed;
                this.color = '#ff416c'; 
                this.startY = y_absolute;
                this.startX = x; 

                if (type.includes('moving')) {
                    this.color = '#4dffa6';
                }
            }

            update() {
                if (this.type === 'moving-h') {
                    this.x += this.speed;
                    if (this.x < WALL_X || this.x + this.w > WALL_X + WALL_WIDTH) {
                        this.speed *= -1;
                    }
                } else if (this.type === 'moving-v') {
                    this.y += this.speed;
                    if (this.y < this.startY - 100 || this.y > this.startY + 100) {
                        this.speed *= -1;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.w, this.h);
            }
        }

        class Obstacle {
            constructor(x, y_absolute, w, h, type = 'sweeper', speed = 0) {
                this.x = x;
                this.y = y_absolute; 
                this.w = w;
                this.h = h;
                this.type = type;
                this.speed = speed;
                this.color = '#ff0000';
                this.startY = y_absolute; 
                this.startX = x;
                this.toRemove = false; 
            }

            update() {
                if (this.type === 'sweeper') {
                    this.x += this.speed;
                    if (this.x < WALL_X || this.x + this.w > WALL_X + WALL_WIDTH) {
                        this.speed *= -1;
                    }
                } else if (this.type === 'bouncer') {
                    this.y += this.speed;
                    if (this.y < this.startY - 150 || this.y > this.startY + 150) {
                        this.speed *= -1;
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.w, this.h);
                
                ctx.fillStyle = '#ff9999';
                ctx.fillRect(this.x, this.y - scrollY, this.w, 3);
                ctx.fillRect(this.x, this.y - scrollY + this.h - 3, this.w, 3);
            }
        }

        class BaseMushroom { 
            constructor(x, y_absolute, parentPlatform, capColor, dotColor) {
                this.w = 15;
                this.h = 15;
                this.x = x;
                this.y = y_absolute;
                this.toRemove = false;
                this.platform = parentPlatform;
                this.speed = 0.8; 
                this.capColor = capColor;
                this.dotColor = dotColor;
                this.minX = this.platform.x + 5;
                this.maxX = this.platform.x + this.platform.w - this.w - 5;
            }

            update() {
                this.minX = this.platform.x + 5;
                this.maxX = this.platform.x + this.platform.w - this.w - 5;
                this.x += this.speed;
                if (this.x < this.minX || this.x > this.maxX) {
                    this.speed *= -1;
                }
                if (this.platform.type.includes('moving')) {
                    this.y = this.platform.y - this.h;
                }
            }

            draw() {
                const screenY = this.y - scrollY;
                // Base/Stem color (Dark Grey)
                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x + this.w/2 - 3, screenY + 5, 6, 10);
                // Cap color
                ctx.fillStyle = this.capColor;
                ctx.beginPath();
                ctx.arc(this.x + this.w / 2, screenY + 5, this.w / 2, Math.PI, 0, false);
                ctx.closePath();
                ctx.fill();
                // Add small spots
                ctx.fillStyle = this.dotColor;
                ctx.fillRect(this.x + 3, screenY + 2, 2, 2);
                ctx.fillRect(this.x + 10, screenY + 2, 2, 2);
            }
        }

        // Poison Mushroom (Red)
        class PoisonMushroom extends BaseMushroom {
            constructor(x, y_absolute, parentPlatform) {
                super(x, y_absolute, parentPlatform, '#FF0000', '#FFFFFF'); // Red
            }
        }

        // Antidote Mushroom (Green)
        class AntidoteMushroom extends BaseMushroom {
            constructor(x, y_absolute, parentPlatform) {
                super(x, y_absolute, parentPlatform, '#34D399', '#FFFFFF'); // Emerald Green
            }
        }
        
        // Tool Class
        class Tool {
            constructor(x, y_absolute, type) {
                this.x = x;
                this.y = y_absolute;
                this.width = 15;
                this.height = 15;
                this.type = type;
                this.color = '#00FFFF'; // Cyan for laser gun
                this.toRemove = false;
            }

            draw() {
                // Draw as a triangle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y - scrollY); // Top center
                ctx.lineTo(this.x, this.y - scrollY + this.height); // Bottom left
                ctx.lineTo(this.x + this.width, this.y - scrollY + this.height); // Bottom right
                ctx.closePath();
                ctx.fill();
            }
        }

        // Laser Class
        class Laser {
            constructor(x, y_absolute) {
                this.x = x;
                this.y = y_absolute;
                this.width = 4;
                this.height = 20;
                this.vy = -35;
                this.color = '#FFFF00';
                this.toRemove = false;
            }

            update() {
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y - scrollY, this.width, this.height);
            }
        }

        // --- Game Logic Functions ---
        
        function generateNewPlatforms(start_y) {
            let current_y = start_y;
            const targetY = current_y - GENERATION_BUFFER_Y;
            let previous_y = start_y;

            while (current_y > targetY) {
                const y_gap = Math.floor(Math.random() * (PLATFORM_GAP_MAX - PLATFORM_GAP_MIN) + PLATFORM_GAP_MIN);
                current_y -= y_gap;

                // Determine platform properties
                const w = Math.floor(Math.random() * (PLATFORM_WIDTH_MAX - PLATFORM_WIDTH_MIN) + PLATFORM_WIDTH_MIN);
                const max_x = WALL_X + WALL_WIDTH - w;
                const x = Math.floor(Math.random() * (max_x - WALL_X) + WALL_X);
                const h = 10;

                // Randomly decide platform type
                const rand = Math.random();
                let type = 'static';
                let speed = 0;
                if (rand > 0.7) {
                    if (Math.random() > 0.5) {
                        type = 'moving-h';
                        speed = Math.random() < 0.5 ? 1.5 : -1.5;
                    } else {
                        type = 'moving-v';
                        speed = Math.random() < 0.5 ? 1 : -1;
                    }
                }

                // Push platform
                const p = new Platform(0, x, current_y, w, h, type, speed);
                gameState.platforms.push(p);

                // 1. Tool Generation 
                if (p.type === 'static' && Math.random() < 0.08 && (!gameState.player || gameState.player.currentTool === 'none')) {
                    const tool_w = 15;
                    const tool_h = 15;
                    const tool_x = p.x + (p.w / 2) - (tool_w / 2);
                    const tool_y = p.y - tool_h - 2;
                    gameState.tools.push(new Tool(tool_x, tool_y, 'laser_gun'));
                }
                
                // 2. Poison Mushroom Generation (Red, 15% chance)
                if (p.type === 'static' && Math.random() < 0.15 && p.w > 40) {
                    const mush_w = 15;
                    const mush_h = 15;
                    const mush_x = p.x + (p.w / 2) - (mush_w / 2); // Start in center
                    const mush_y = p.y - mush_h;
                    gameState.mushrooms.push(new PoisonMushroom(mush_x, mush_y, p));
                }

                // 3. Antidote Mushroom Generation (Green, 8% chance)
                if (p.type === 'static' && Math.random() < 0.08 && p.w > 40) {
                    const mush_w = 15;
                    const mush_h = 15;
                    const mush_x = p.x + (p.w / 2) - (mush_w / 2);
                    const mush_y = p.y - mush_h;
                    gameState.antidotes.push(new AntidoteMushroom(mush_x, mush_y, p));
                }

                // 4. Obstacle Generation Logic (between platforms)
                if (Math.random() < 0.25) {
                    const obs_w = Math.floor(Math.random() * 40) + 20;
                    const obs_h = 20;
                    const safe_margin = 10;
                    const obs_y_min = current_y + obs_h + safe_margin;
                    const obs_y_max = previous_y - safe_margin - 30;

                    if (obs_y_max > obs_y_min) {
                        const obs_y = Math.floor(Math.random() * (obs_y_max - obs_y_min) + obs_y_min);
                        const obs_x_max = WALL_X + WALL_WIDTH - obs_w;
                        const obs_x = Math.floor(Math.random() * (obs_x_max - WALL_X) + WALL_X);
                        let obs_type = Math.random() > 0.5 ? 'sweeper' : 'bouncer';
                        let obs_speed = obs_type === 'sweeper' ? (Math.random() < 0.5 ? 2.5 : -2.5) : (Math.random() < 0.5 ? 1.5 : -1.5);
                        gameState.obstacles.push(new Obstacle(obs_x, obs_y, obs_w, obs_h, obs_type, obs_speed));
                    }
                }

                previous_y = current_y + y_gap;
                highestPlatformY = Math.min(highestPlatformY, current_y);
            }
        }
        
        function loadInitialLevels() {
            gameState.platforms = [];
            gameState.obstacles = [];
            gameState.tools = [];
            gameState.lasers = [];
            gameState.mushrooms = [];
            gameState.antidotes = [];

            highestPlatformY = canvas.height;

            // Create starting platform
            gameState.platforms.push(new Platform(0, WALL_X, canvas.height - 30, WALL_WIDTH, 30, 'static'));

            // Set player position
            gameState.player = new Player(canvas.width / 2 - 10, canvas.height - 60);
            gameState.player.vy = 0;
            gameState.player.currentTool = 'none';
            gameState.player.poisonHits = 0;
            gameState.player.flashTimer = 0;
            // NEW: Anti-bug flag
            gameState.player.headBumped = 0; // Tracks frames player cannot score after a head-bump

            // Generate initial set of platforms
            generateNewPlatforms(canvas.height - 100);

            // Reset scroll and score
            scrollY = 0;
            distanceClimbed = 0;

            updateLevelDisplay();
            updateToolDisplay();
            updatePoisonDisplay();

            // Ensure the score submission form is hidden upon restart (NEW FROM V8)
            const scoreSubmitForm = document.getElementById('scoreSubmitForm');
            if (scoreSubmitForm) scoreSubmitForm.classList.add('hidden');
            messageBox.style.display = 'none';
        }

        function checkCollision(obj1, obj2) {
            // obj1 has width/height, obj2 has w/h
            return (
                obj1.x < obj2.x + obj2.w &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.h &&
                obj1.y + obj1.height > obj2.y
            );
        }

        function updateGame() {
            if (gameState.isGameOver) return;

            const player = gameState.player;
            
            // NEW: Decrement head-bump timer
            if (player.headBumped > 0) {
                player.headBumped--;
            }

            player.update();

            // Update entities
            const discardThresholdY = scrollY + canvas.height + 100;

            // Update and Filter Entities
            gameState.platforms.forEach(p => p.update());
            gameState.platforms = gameState.platforms.filter(p => p.y < discardThresholdY);

            gameState.obstacles.forEach(o => o.update());
            gameState.obstacles = gameState.obstacles.filter(o => !o.toRemove && o.y < discardThresholdY);
            
            gameState.mushrooms.forEach(m => m.update());
            gameState.mushrooms = gameState.mushrooms.filter(m => !m.toRemove && m.y < discardThresholdY);

            gameState.antidotes.forEach(a => a.update()); // Update antidote movement (NEW)
            gameState.antidotes = gameState.antidotes.filter(a => !a.toRemove && a.y < discardThresholdY); // Filter antidotes (NEW)

            gameState.tools = gameState.tools.filter(t => !t.toRemove && t.y < discardThresholdY);

            gameState.lasers.forEach(l => l.update());
            gameState.lasers = gameState.lasers.filter(l => !l.toRemove && l.y > scrollY - 200);

            // --- Collision Detection ---

            // 1. Player vs Platform (Landing/Bumping)
            let landed = false;
            gameState.platforms.forEach(p => {
                if (checkCollision(player, p)) {
                    if (player.vy > 0 && player.y + player.height <= p.y + p.h) { // Landing
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                        player.jumpsUsed = 0;
                        landed = true;

                        // If platform is moving, player moves with it
                        if (p.type === 'moving-h') {
                            player.x += p.speed;
                        } else if (p.type === 'moving-v') {
                            player.y += p.speed;
                        }
                    } else if (player.vy < 0) { // Player hits bottom of platform (head bump)
                        // === FIX for Infinite Climb Bug (Physical Response) ===
                        player.vy = 5; // Force a small downward bounce
                        player.y = p.y + p.h; // Place player below the platform
                        player.onGround = false;
                        player.jumpsUsed = MAX_JUMPS; // Prevent further jump/float until they land on a proper platform
                        
                        // === NEW FIX for Infinite Climb Bug (Score Lock) ===
                        player.headBumped = 10; // Disable score increase for 10 frames
                        // =================================
                    }
                    // Side collision logic is simplified for now but typically involves complex checks
                }
            });
            
            // If the player collided but the landing logic didn't trigger, they are in the air.
            if (!landed && player.onGround) {
                player.onGround = false;
            }

            // Player falls off screen (Game Over condition)
            if (player.y - scrollY > canvas.height) {
                gameOver('You fell into the abyss');
                return;
            }

            // Player hits ceiling (bounce down slightly)
            const ceilingY = highestPlatformY - 50;
            if (player.y < ceilingY && scrollY > 0) {
                player.y = ceilingY;
                player.vy = 0;
            }

            // Obstacle collision
            gameState.obstacles.forEach(o => {
                if (checkCollision(player, o) && player.flashTimer <= 0) {
                    gameOver('You were caught by a dangerous hazard');
                    return;
                }
            });

            // Tool collision
            gameState.tools.forEach(tool => {
                if (checkCollision(player, tool)) {
                    player.currentTool = tool.type; // 'laser_gun'
                    player.laserCooldown = 0;
                    tool.toRemove = true;
                    updateToolDisplay();
                }
            });
            gameState.tools = gameState.tools.filter(t => !t.toRemove);

            // Poison Mushroom collision
            gameState.mushrooms.forEach(m => {
                if (checkCollision(player, {x: m.x, y: m.y, w: m.w, h: m.h})) {
                    if (player.poisonHits < 3 && player.flashTimer <= 0) {
                        player.poisonHits++;
                        player.flashTimer = 50; // Flash for visual feedback
                        updatePoisonDisplay();
                    }
                    m.toRemove = true;
                    if (player.poisonHits >= 3) {
                        gameOver('You consumed too much poison!');
                        return;
                    }
                }
            });
            gameState.mushrooms = gameState.mushrooms.filter(m => !m.toRemove);

            // Antidote Mushroom collision (NEW)
            gameState.antidotes.forEach(a => {
                if (checkCollision(player, {x: a.x, y: a.y, w: a.w, h: a.h})) {
                    if (player.poisonHits > 0 && player.flashTimer <= 0) {
                        player.poisonHits--;
                        player.flashTimer = 30;
                        updatePoisonDisplay();
                    }
                    a.toRemove = true;
                }
            });
            gameState.antidotes = gameState.antidotes.filter(a => !a.toRemove);


            // Laser collision (with everything except player)
            gameState.lasers.forEach(laser => {
                // Check vs Obstacles
                gameState.obstacles.forEach(o => {
                    if (checkCollision({x: laser.x, y: laser.y, width: laser.width, height: laser.height}, o)) {
                        laser.toRemove = true;
                        o.toRemove = true;
                    }
                });
                // Check vs Poison Mushrooms
                gameState.mushrooms.forEach(m => {
                    if (checkCollision({x: laser.x, y: laser.y, width: laser.width, height: laser.height}, {x: m.x, y: m.y, w: m.w, h: m.h})) {
                        laser.toRemove = true;
                        m.toRemove = true;
                    }
                });
                // Check vs Antidote Mushrooms
                gameState.antidotes.forEach(a => {
                    if (checkCollision({x: laser.x, y: laser.y, width: laser.width, height: laser.height}, {x: a.x, y: a.y, w: a.w, h: a.h})) {
                        laser.toRemove = true;
                        a.toRemove = true;
                    }
                });
            });
            gameState.lasers = gameState.lasers.filter(l => !l.toRemove);


            // --- Infinite Climbing / Generation Logic ---
            const playerScreenY = player.y - scrollY;
            const scrollThreshold = canvas.height * 0.4;
            
            if (playerScreenY < scrollThreshold) {
                // Player is in the top 40% of the screen, scroll up.
                const scrollAmount = scrollThreshold - playerScreenY;
                scrollY += scrollAmount;
                
                // FIX: Only increase score if player hasn't just been head-bumped.
                if (player.headBumped <= 0) { 
                    distanceClimbed += scrollAmount / 10; // Convert pixels to 'meters' (10px = 1m)
                }
                
                updateLevelDisplay();
            }

            // Check if more platforms need to be generated
            if (highestPlatformY > scrollY) {
                generateNewPlatforms(highestPlatformY);
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw boundaries (walls)
            ctx.fillStyle = '#3c004d'; // Purple walls
            ctx.fillRect(0, 0, WALL_X, canvas.height); // Left wall
            ctx.fillRect(WALL_X + WALL_WIDTH, 0, WALL_X, canvas.height); // Right wall

            // Draw all entities
            gameState.platforms.forEach(p => p.draw());
            gameState.obstacles.forEach(o => o.draw());
            gameState.tools.forEach(t => t.draw());
            gameState.mushrooms.forEach(m => m.draw());
            gameState.antidotes.forEach(a => a.draw());
            gameState.lasers.forEach(l => l.draw());

            // Draw player
            if (gameState.player) {
                gameState.player.draw();
            }
        }

        function runGameLoop() {
            requestAnimationFrame(runGameLoop);
            if (!gameState.isGameOver && gameState.player) {
                updateGame();
                drawGame();
            }
        }

        function updateLevelDisplay() {
            levelDisplay.textContent = `Climb: ${distanceClimbed.toFixed(0)} meters`;
        }
        
        function updateToolDisplay() {
            toolDisplay.textContent = `Tool: ${gameState.player.currentTool === 'laser_gun' ? 'LASER (X)' : 'None'}`;
        }

        function updatePoisonDisplay() {
            if (!gameState.player) return;
            const hits = gameState.player.poisonHits;
            poisonDisplay.textContent = `Poison: ${hits} / 3`;
            
            // Adjust text color based on poison level (FROM V8)
            if (hits > 0) {
                poisonDisplay.classList.remove('text-red-500', 'text-gray-400', 'text-yellow-500');
                poisonDisplay.classList.add(hits === 3 ? 'text-red-600' : 'text-yellow-500');
            } else {
                poisonDisplay.classList.remove('text-red-600', 'text-yellow-500');
                poisonDisplay.classList.add('text-red-500'); // Original V5 color was red-500
            }
        }
        
        // MODIFIED gameOver FUNCTION (USING V8'S SCORE SUBMISSION LOGIC)
        function gameOver(reason) {
            gameState.isGameOver = true;
            messageTitle.textContent = 'Game Over!';
            messageText.innerHTML = `You fell! Your highest climb was: <span class="text-fuchsia-400 font-bold">${distanceClimbed.toFixed(0)} meters</span>. ${reason}`;
            
            // Hide the plain restart button
            restartButton.classList.add('hidden');
            
            // Show the score submission form
            scoreSubmitForm.classList.remove('hidden');
            
            // Set a random default name for quick saving IF the input field is empty
            let savedName = loadPlayerName();
            if (!savedName) {
                savedName = generateRandomName();
            }
            playerNameInput.value = savedName;

            messageBox.style.display = 'block';
        }

        function resetGame() {
            gameState.isGameOver = false;
            loadInitialLevels();
        }


        // --- Input Handling (Keyboard) ---
        document.addEventListener('keydown', (e) => {
            if (gameState.isGameOver) return;
            
            // Check for Jump keys (Space, ArrowUp, W)
            const isJumpKey = (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w');
            if (isJumpKey) {
                e.preventDefault();
                // FIX: Only call jump() on the initial press, not on key-repeat.
                // The check must happen BEFORE the key is marked as 'true' below.
                if(gameState.player && !gameState.keys[e.key]) { 
                    gameState.player.jump();
                }
            }

            // Handle movement keys (held down) - This also saves 'ArrowUp' state for float logic
            gameState.keys[e.key] = true;

            // Fire laser on 'x' press
            if (e.key.toLowerCase() === 'x') {
                e.preventDefault();
                if(gameState.player) gameState.player.fireLaser();
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        // --- Input Handling (Touch) ---
        const touchLeft = document.getElementById('touchLeft');
        const touchRight = document.getElementById('touchRight');
        const touchJump = document.getElementById('touchJump');
        const touchFire = document.getElementById('touchFire');

        /**
         * Generic function to set up touch events for a control button.
         * @param {HTMLElement} button 
         * @param {string} key - The virtual key to simulate (e.g., 'ArrowLeft')
         * @param {boolean} isHoldAction - True if the action should trigger once on press, even if held.
         */
        const setupButtonEvents = (button, key, isHoldAction = false) => {
            const pressEvent = () => {
                if (gameState.isGameOver) return;
                
                // FIX: Handle jump on initial press, checking the state BEFORE setting it true
                if (key === 'ArrowUp') {
                    if (gameState.player) { 
                        gameState.player.jump();
                    }
                }
                // Handle Fire (X) as a single-shot action on press
                else if (key === 'x' && gameState.player) {
                    gameState.player.fireLaser();
                }

                // Set the key state to true (used for horizontal movement and float mechanic)
                gameState.keys[key] = true;
            };

            const releaseEvent = () => {
                gameState.keys[key] = false;
            };

            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                pressEvent();
            }, { passive: false });
            button.addEventListener('touchend', releaseEvent);
            button.addEventListener('mousedown', pressEvent);
            button.addEventListener('mouseup', releaseEvent);
            button.addEventListener('mouseleave', releaseEvent); // Important for mouse drag off
        };


        setupButtonEvents(touchLeft, 'ArrowLeft');
        setupButtonEvents(touchRight, 'ArrowRight');
        setupButtonEvents(touchJump, 'ArrowUp', true); // Jump/Float
        setupButtonEvents(touchFire, 'x', true); // Fire is an instant action + hold for rapid fire


        // --- Leaderboard & Submission Handlers (NEW FROM V8) ---
        saveScoreButton.onclick = async () => {
            const finalName = playerNameInput.value.trim() || generateRandomName();
            savePlayerName(finalName);

            saveScoreButton.disabled = true;
            saveScoreButton.textContent = 'Saving...';
            
            // 1. Save the score asynchronously
            await saveScore(finalName, distanceClimbed);

            // 2. Restart the game
            saveScoreButton.disabled = false;
            saveScoreButton.textContent = 'Save Score & Restart';
            resetGame();
        };

        restartWithoutSaveButton.onclick = () => {
            resetGame();
        };

        viewLeaderboardButton.onclick = () => {
            leaderboardModal.style.display = 'block';
        };

        closeLeaderboardButton.onclick = () => {
            leaderboardModal.style.display = 'none';
        };


        /**
         * Initializes Firebase authentication and then calls startGame().
         */
        const initGame = async () => {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    
                    // 1. Initialize App
                    app = initializeApp(firebaseConfig);
                    
                    // 2. Initialize Realtime Database
                    db = getDatabase(app); 
                    
                    // 3. Initialize Auth and sign in anonymously
                    auth = getAuth(app);
                    await signInAnonymously(auth);
                    
                    // On success, update userId from 'anon' to the persistent UID
                    userId = auth.currentUser?.uid || 'anon';
                    console.log("Firebase Auth successful. User ID:", userId);
                    console.log("Realtime Database connected at:", firebaseConfig.databaseURL);

                    // 4. Setup Leaderboard Listener
                    setupLeaderboardListener();

                } else {
                    console.warn("Firebase config not available. Starting game without database/leaderboard.");
                }
            } catch (e) {
                // If this fails, userId remains 'anon', and the saveScore check will block the save.
                console.error("Critical Firebase error during initialization/auth:", e); 
            }
            
            // Initialize game state (player, platforms) before starting the loop.
            resetGame(); 
            
            // ALWAYS start the game loop after attempting Firebase init
            runGameLoop();
        };

        // Call the initialization function immediately after the script loads
        initGame();
    </script>
</body>
</html>
